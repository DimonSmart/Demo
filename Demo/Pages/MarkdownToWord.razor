@page "/markdown-to-word"
@using System.Text
@using Demo.Demos.MarkdownToWord
@using Demo.Services
@using Markdig

@inject PageTitleService PageTitleService
@inject IJSRuntime JSRuntime
@inject InvisibleCharacterDetectorService CharacterDetector
@inject InvisibleCharacterVisualizationService CharacterVisualizer
<link rel="stylesheet" href="css/demos.css" />
<style>
@((MarkupString)CharacterVisualizer.GenerateVisualizationCSS())

.invisible-char-controls {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 15px;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 12px;
}

.control-group {
    display: flex;
    align-items: center;
    gap: 8px;
}

.control-group select {
    flex: 1;
}

.btn-clean {
    white-space: normal;
    line-height: 1.2;
}
</style>

<PageTitle>Markdown to Word</PageTitle>
<div class="page-container">
    <!-- Invisible Character Controls -->
    <div class="invisible-char-controls">
        <div class="row mb-3">
            <div class="col-md-6">
                <div class="btn-group d-flex" role="group">
                    <input type="radio"
                           class="btn-check"
                           name="viewMode"
                           id="preview"
                           checked="@(CurrentViewMode == ViewMode.Preview)"
                           @onchange="@(() => SetViewMode(ViewMode.Preview))" />
                    <label class="btn btn-outline-primary flex-fill" for="preview">Preview</label>

                    <input type="radio"
                           class="btn-check"
                           name="viewMode"
                           id="invisibleChars"
                           checked="@(CurrentViewMode == ViewMode.InvisibleCharacters)"
                           @onchange="@(() => SetViewMode(ViewMode.InvisibleCharacters))" />
                    <label class="btn btn-outline-primary flex-fill" for="invisibleChars">Invisible Characters</label>
                </div>
            </div>

            <div class="col-md-6">
                <div class="control-group w-100">
                    <label class="form-label mb-0" for="presetSelect">Cleaning preset</label>
                    <select id="presetSelect" class="form-select" @bind="SelectedPreset">
                        <option value="@CleaningPreset.Safe">Safe</option>
                        <option value="@CleaningPreset.Aggressive">Aggressive</option>
                        <option value="@CleaningPreset.ASCIIStrict">ASCII-Strict</option>
                        <option value="@CleaningPreset.TypographySoft">Typography-Soft</option>
                        <option value="@CleaningPreset.RTLSafe">RTL-Safe</option>
                        <option value="@CleaningPreset.SEOPlain">SEO/Plain</option>
                    </select>
                </div>
            </div>
        </div>

        @if (CurrentViewMode == ViewMode.InvisibleCharacters)
        {
            <div class="row mb-3">
                <div class="col-12">
                    <div class="card">
                        <div class="card-header">
                            <h6 class="mb-0">Invisible Character Categories</h6>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                @foreach (var category in Enum.GetValues<InvisibleCharacterCategory>())
                                {
                                    <div class="col-md-4 mb-2">
                                        <div class="form-check">
                                            <input class="form-check-input" 
                                                   type="checkbox" 
                                                   id="cat-@category" 
                                                   checked="@EnabledCategories.Contains(category)"
                                                   @onchange="@(e => ToggleCategory(category, (bool)e.Value!))" />
                                            <label class="form-check-label" for="cat-@category">
                                                @GetCategoryDisplayName(category)
                                            </label>
                                        </div>
                                    </div>
                                }
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        }
        
        <div class="row mb-3">
            <div class="col-12 col-md-6 col-lg-4">
                <button class="btn btn-warning w-100 btn-clean" @onclick="DeleteInvisibleCharacters" disabled="@(!HasCharactersToClean)">
                    Clean Selected (@CharactersToCleanCount)
                </button>
            </div>
        </div>
    </div>

    <!-- Existing Controls -->
    <div>
        <div class="mb-2">
            <button class="btn btn-secondary" @onclick='() => ToggleMarkdownAction("**")' style="font-weight: bold;">B</button>
            <button class="btn btn-secondary" @onclick='() => ToggleMarkdownAction("_")' style="font-style: italic;">I</button>
            <button class="btn btn-secondary" @onclick='() => ToggleMarkdownAction("~~")' style="text-decoration: line-through;">S</button>
            <button class="btn btn-secondary" @onclick='() => ToggleMarkdownAction("`")' style="font-family: monospace;">`code`</button>
            <button class="btn btn-info ms-3" @onclick="LoadExample" title="Load compact text with invisible characters for testing">Show Example</button>
        </div>
    </div>

    <div class="d-flex" style="height: calc(100vh - 200px);">
        <div class="form-group" style="width: 50%; margin-right: 1rem; display: flex; flex-direction: column;">
            <label for="markdownInput" class="form-label">Markdown Content</label>
            <textarea id="markdownInput" class="form-control" style="flex-grow: 1; resize: none;" @ref="MarkdownTextArea" @oninput="OnInput">@MarkdownContent</textarea>
        </div>

        <div class="form-group" style="width: 50%; display: flex; flex-direction: column;">
            <label class="form-label">@(CurrentViewMode == ViewMode.Preview ? "Preview" : "Text with Invisible Characters")</label>
            <div id="preview" class="form-control" style="flex-grow: 1; overflow-y: auto; white-space: pre-wrap;">
                @if (CurrentViewMode == ViewMode.InvisibleCharacters)
                {
                    @((MarkupString)VisualizedPreview)
                }
                else
                {
                    @((MarkupString)MarkdownPreview)
                }
            </div>
        </div>
    </div>

    <div class="d-flex align-items-center mt-2">
        <a class="btn btn-primary" href="@DownloadUrl" download="ExportedDocument.doc">Download as Word</a>
        <p class="text-primary ms-3" style="font-style: italic;">All processing is done entirely in your browser, and no data is transmitted to any server.</p>
    </div>
</div>

@code {
    private enum ViewMode
    {
        Preview,
        InvisibleCharacters
    }

    private ElementReference MarkdownTextArea;
    private string MarkdownContent { get; set; } = string.Empty;
    private string MarkdownPreview { get; set; } = string.Empty;
    private string VisualizedPreview { get; set; } = string.Empty;
    private string DownloadUrl { get; set; } = string.Empty;
    private DetectionResult LatestDetectionResult { get; set; } = new();
    private Markdig.MarkdownPipeline MarkdownPipeline =
        new Markdig.MarkdownPipelineBuilder()
        .UseEmphasisExtras()
        .Build();

    private ViewMode CurrentViewMode { get; set; } = ViewMode.Preview;
    private bool ShowInvisibleCharacters => CurrentViewMode == ViewMode.InvisibleCharacters;
    private HashSet<InvisibleCharacterCategory> EnabledCategories { get; set; } = new();

    private static readonly IReadOnlyDictionary<CleaningPreset, InvisibleCharacterCategory[]> PresetCategoryMap =
        new Dictionary<CleaningPreset, InvisibleCharacterCategory[]>
        {
            [CleaningPreset.Safe] = new[]
            {
                InvisibleCharacterCategory.C0C1Controls,
                InvisibleCharacterCategory.LineBreaks,
                InvisibleCharacterCategory.Tab,
                InvisibleCharacterCategory.WideSpaces,
                InvisibleCharacterCategory.ZeroWidthFormat,
                InvisibleCharacterCategory.BiDiControls,
                InvisibleCharacterCategory.SoftHyphen,
                InvisibleCharacterCategory.InvisibleMath
            },
            [CleaningPreset.Aggressive] = new[]
            {
                InvisibleCharacterCategory.C0C1Controls,
                InvisibleCharacterCategory.LineBreaks,
                InvisibleCharacterCategory.Tab,
                InvisibleCharacterCategory.WideSpaces,
                InvisibleCharacterCategory.NoBreakSpaces,
                InvisibleCharacterCategory.ZeroWidthFormat,
                InvisibleCharacterCategory.BiDiControls,
                InvisibleCharacterCategory.SoftHyphen,
                InvisibleCharacterCategory.InvisibleMath,
                InvisibleCharacterCategory.VariationSelectors,
                InvisibleCharacterCategory.EmojiTags,
                InvisibleCharacterCategory.Confusables
            },
            [CleaningPreset.ASCIIStrict] = new[]
            {
                InvisibleCharacterCategory.C0C1Controls,
                InvisibleCharacterCategory.LineBreaks,
                InvisibleCharacterCategory.Tab,
                InvisibleCharacterCategory.WideSpaces,
                InvisibleCharacterCategory.NoBreakSpaces,
                InvisibleCharacterCategory.ZeroWidthFormat,
                InvisibleCharacterCategory.BiDiControls,
                InvisibleCharacterCategory.SoftHyphen,
                InvisibleCharacterCategory.InvisibleMath,
                InvisibleCharacterCategory.VariationSelectors,
                InvisibleCharacterCategory.EmojiTags,
                InvisibleCharacterCategory.Confusables
            },
            [CleaningPreset.TypographySoft] = new[]
            {
                InvisibleCharacterCategory.C0C1Controls,
                InvisibleCharacterCategory.LineBreaks,
                InvisibleCharacterCategory.Tab,
                InvisibleCharacterCategory.WideSpaces,
                InvisibleCharacterCategory.ZeroWidthFormat,
                InvisibleCharacterCategory.BiDiControls,
                InvisibleCharacterCategory.SoftHyphen,
                InvisibleCharacterCategory.InvisibleMath
            },
            [CleaningPreset.RTLSafe] = new[]
            {
                InvisibleCharacterCategory.C0C1Controls,
                InvisibleCharacterCategory.LineBreaks,
                InvisibleCharacterCategory.Tab,
                InvisibleCharacterCategory.WideSpaces,
                InvisibleCharacterCategory.ZeroWidthFormat,
                InvisibleCharacterCategory.SoftHyphen,
                InvisibleCharacterCategory.InvisibleMath
            },
            [CleaningPreset.SEOPlain] = new[]
            {
                InvisibleCharacterCategory.C0C1Controls,
                InvisibleCharacterCategory.LineBreaks,
                InvisibleCharacterCategory.Tab,
                InvisibleCharacterCategory.WideSpaces,
                InvisibleCharacterCategory.NoBreakSpaces,
                InvisibleCharacterCategory.ZeroWidthFormat,
                InvisibleCharacterCategory.BiDiControls,
                InvisibleCharacterCategory.SoftHyphen,
                InvisibleCharacterCategory.InvisibleMath,
                InvisibleCharacterCategory.VariationSelectors,
                InvisibleCharacterCategory.EmojiTags,
                InvisibleCharacterCategory.Confusables
            }
        };

    private CleaningPreset selectedPreset = CleaningPreset.Safe;
    private CleaningPreset SelectedPreset
    {
        get => selectedPreset;
        set
        {
            if (selectedPreset != value)
            {
                selectedPreset = value;
                _ = InvokeAsync(async () =>
                {
                    ApplyPresetCategories(selectedPreset);
                    await UpdatePreview();
                    StateHasChanged();
                });
            }
        }
    }

    private bool HasCharactersToClean => EnabledCategories.Count > 0 &&
        LatestDetectionResult.DetectedCharacters.Any(dc => EnabledCategories.Contains(dc.Category));

    private int CharactersToCleanCount => EnabledCategories.Count == 0
        ? 0
        : LatestDetectionResult.DetectedCharacters.Count(dc => EnabledCategories.Contains(dc.Category));
    
    // Visualization options
    private VisualizationOptions VisualizationOptions => new()
    {
        ShowInvisibleCharacters = ShowInvisibleCharacters,
        SkipCodeBlocks = true,
        ShowLineBreaks = true,
        EnabledCategories = EnabledCategories
    };

    protected override async Task OnInitializedAsync()
    {
        base.OnInitialized();
        PageTitleService.SetTitle("Markdown to Word");

        ApplyPresetCategories(SelectedPreset);

        await UpdatePreview();
    }

    private void ApplyPresetCategories(CleaningPreset preset)
    {
        if (PresetCategoryMap.TryGetValue(preset, out var categories))
        {
            EnabledCategories = new HashSet<InvisibleCharacterCategory>(categories);
        }
        else
        {
            EnabledCategories = new HashSet<InvisibleCharacterCategory>(Enum.GetValues<InvisibleCharacterCategory>());
        }
    }

    private async Task ToggleMarkdownAction(string markdownSymbol)
    {
        var selectionStart = await JSRuntime.InvokeAsync<int>("getSelectionStart", MarkdownTextArea);
        var selectionEnd = await JSRuntime.InvokeAsync<int>("getSelectionEnd", MarkdownTextArea);

        if (selectionStart >= 0 && selectionEnd > selectionStart)
        {
            MarkdownContent = MarkdownProcessor.ToggleMarkdown(MarkdownContent, selectionStart, selectionEnd, markdownSymbol);

            // Update the textarea content explicitly
            await JSRuntime.InvokeVoidAsync("updateTextAreaContent", MarkdownTextArea, MarkdownContent);

            // Update preview
            await UpdatePreview();
        }
    }

    private async Task OnInput(ChangeEventArgs e)
    {
        MarkdownContent = e.Value?.ToString() ?? string.Empty;
        await UpdatePreview();
    }

    private Task UpdatePreview()
    {
        var content = MarkdownContent ?? string.Empty;
        LatestDetectionResult = CharacterDetector.DetectInvisibleCharacters(content);
        MarkdownPreview = Markdig.Markdown.ToHtml(content, MarkdownPipeline);

        if (CurrentViewMode == ViewMode.InvisibleCharacters)
        {
            // Generate visualized preview with only enabled categories
            var visualizedMarkdown = CharacterVisualizer.VisualizeInvisibleCharacters(content, VisualizationOptions);
            VisualizedPreview = Markdig.Markdown.ToHtml(visualizedMarkdown, MarkdownPipeline);
        }
        else
        {
            VisualizedPreview = MarkdownPreview;
        }

        GenerateDownloadUrl();
        return Task.CompletedTask;
    }

    private void GenerateDownloadUrl()
    {
        string htmlContent = Markdig.Markdown.ToHtml(MarkdownContent, MarkdownPipeline); // Convert Markdown to HTML

        // Wrap HTML content into a basic Word file structure
        string wordContent = $@"<html xmlns:o='urn:schemas-microsoft-com:office:office'
                            xmlns:w='urn:schemas-microsoft-com:office:word'
                            xmlns='http://www.w3.org/TR/REC-html40'>
<head><meta charset='utf-8'></head>
<body>{htmlContent}</body>
</html>";

        // Convert the content to base64 string
        var byteArray = Encoding.UTF8.GetBytes(wordContent);
        DownloadUrl = "data:application/msword;base64," + Convert.ToBase64String(byteArray);
    }

    private async Task SetViewMode(ViewMode mode)
    {
        CurrentViewMode = mode;
        await UpdatePreview();
        StateHasChanged();
    }

    private async Task ToggleCategory(InvisibleCharacterCategory category, bool enabled)
    {
        if (enabled)
        {
            EnabledCategories.Add(category);
        }
        else
        {
            EnabledCategories.Remove(category);
        }
        
        await UpdatePreview();
        StateHasChanged();
    }

    private async Task DeleteInvisibleCharacters()
    {
        if (!HasCharactersToClean)
            return;

        var detectionResult = CharacterDetector.DetectInvisibleCharacters(MarkdownContent);

        var charactersToProcess = detectionResult.DetectedCharacters
            .Where(dc => EnabledCategories.Contains(dc.Category))
            .OrderByDescending(dc => dc.Position)
            .ToList();

        if (charactersToProcess.Count == 0)
            return;

        var builder = new StringBuilder(MarkdownContent);
        var hasChanges = false;

        foreach (var detection in charactersToProcess)
        {
            if (TryApplyCleaning(builder, detection))
            {
                hasChanges = true;
            }
        }

        if (!hasChanges)
            return;

        MarkdownContent = builder.ToString();

        await JSRuntime.InvokeVoidAsync("updateTextAreaContent", MarkdownTextArea, MarkdownContent);
        await UpdatePreview();

        StateHasChanged();
    }

    private static bool TryApplyCleaning(StringBuilder builder, CharacterDetection detection)
    {
        var index = detection.Position;

        if (index < 0 || index >= builder.Length)
        {
            return false;
        }

        if (detection.Category == InvisibleCharacterCategory.LineBreaks)
        {
            return NormalizeLineBreak(builder, detection, index);
        }

        builder.Remove(index, 1);
        return true;
    }

    private static bool NormalizeLineBreak(StringBuilder builder, CharacterDetection detection, int index)
    {
        if (detection.CodePoint == 0x000D)
        {
            if (builder[index] != '\r')
            {
                return false;
            }

            if (index + 1 < builder.Length && builder[index + 1] == '\n')
            {
                builder.Remove(index, 1);
            }
            else
            {
                builder[index] = '\n';
            }

            return true;
        }

        if (builder[index] == (char)detection.CodePoint)
        {
            builder[index] = '\n';
            return true;
        }

        return false;
    }

    private string GetCategoryDisplayName(InvisibleCharacterCategory category)
    {
        return category switch
        {
            InvisibleCharacterCategory.C0C1Controls => "C0/C1 Controls",
            InvisibleCharacterCategory.LineBreaks => "Line Breaks",
            InvisibleCharacterCategory.Tab => "Tab",
            InvisibleCharacterCategory.WideSpaces => "Wide Spaces",
            InvisibleCharacterCategory.NoBreakSpaces => "No-Break Spaces",
            InvisibleCharacterCategory.ZeroWidthFormat => "Zero Width Format",
            InvisibleCharacterCategory.BiDiControls => "BiDi Controls",
            InvisibleCharacterCategory.SoftHyphen => "Soft Hyphen",
            InvisibleCharacterCategory.InvisibleMath => "Invisible Math",
            InvisibleCharacterCategory.VariationSelectors => "Variation Selectors",
            InvisibleCharacterCategory.EmojiTags => "Emoji Tags",
            InvisibleCharacterCategory.CombiningMarks => "Combining Marks",
            InvisibleCharacterCategory.Confusables => "Confusables",
            _ => category.ToString()
        };
    }

    private async Task LoadExample()
    {
        var demoContent = InvisibleUnicodeDemoGenerator.BuildMarkdown();
        MarkdownContent = demoContent;

        await JSRuntime.InvokeVoidAsync("updateTextAreaContent", MarkdownTextArea, MarkdownContent);
        await UpdatePreview();

        StateHasChanged();
    }
}
