@page "/markdown-to-word"
@using System.Text
@using Demo.Demos.MarkdownToWord
@using Demo.Services
@using Markdig

@inject PageTitleService PageTitleService
@inject IJSRuntime JSRuntime
@inject InvisibleCharacterDetectorService CharacterDetector
@inject InvisibleCharacterCleanerService CharacterCleaner
@inject InvisibleCharacterVisualizationService CharacterVisualizer
<link rel="stylesheet" href="css/demos.css" />
<style>
@((MarkupString)CharacterVisualizer.GenerateVisualizationCSS())

.invisible-char-controls {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 15px;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 12px;
}

.control-group {
    display: flex;
    align-items: center;
    gap: 8px;
}

.control-group select {
    flex: 1;
}

.cleaning-report {
    background: #d4edda;
    border: 1px solid #c3e6cb;
    border-radius: 4px;
    padding: 8px 12px;
    margin: 8px 0;
    font-size: 0.9em;
}

.cleaning-report.error {
    background: #f8d7da;
    border-color: #f5c6cb;
}
</style>

<PageTitle>Markdown to Word</PageTitle>
<div class="page-container">
    <!-- Invisible Character Controls -->
    <div class="invisible-char-controls">
        <div class="row mb-3">
            <div class="col-md-6">
                <div class="btn-group d-flex" role="group">
                    <input type="radio"
                           class="btn-check"
                           name="viewMode"
                           id="preview"
                           checked="@(CurrentViewMode == ViewMode.Preview)"
                           @onchange="@(() => SetViewMode(ViewMode.Preview))" />
                    <label class="btn btn-outline-primary flex-fill" for="preview">Preview</label>

                    <input type="radio"
                           class="btn-check"
                           name="viewMode"
                           id="invisibleChars"
                           checked="@(CurrentViewMode == ViewMode.InvisibleCharacters)"
                           @onchange="@(() => SetViewMode(ViewMode.InvisibleCharacters))" />
                    <label class="btn btn-outline-primary flex-fill" for="invisibleChars">Invisible Characters</label>
                </div>
            </div>

            <div class="col-md-6">
                <div class="control-group w-100">
                    <label class="form-label mb-0" for="presetSelect">Cleaning preset</label>
                    <select id="presetSelect" class="form-select" @bind="SelectedPreset">
                        <option value="@CleaningPreset.Safe">Safe</option>
                        <option value="@CleaningPreset.Aggressive">Aggressive</option>
                        <option value="@CleaningPreset.ASCIIStrict">ASCII-Strict</option>
                        <option value="@CleaningPreset.TypographySoft">Typography-Soft</option>
                        <option value="@CleaningPreset.RTLSafe">RTL-Safe</option>
                        <option value="@CleaningPreset.SEOPlain">SEO/Plain</option>
                    </select>
                    <button type="button" class="btn btn-outline-secondary" @onclick="CleanText">Apply</button>
                </div>
            </div>
        </div>

        @if (CurrentViewMode == ViewMode.InvisibleCharacters)
        {
            <div class="row mb-3">
                <div class="col-12">
                    <div class="card">
                        <div class="card-header">
                            <h6 class="mb-0">Invisible Character Categories</h6>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                @foreach (var category in Enum.GetValues<InvisibleCharacterCategory>())
                                {
                                    <div class="col-md-4 mb-2">
                                        <div class="form-check">
                                            <input class="form-check-input" 
                                                   type="checkbox" 
                                                   id="cat-@category" 
                                                   checked="@EnabledCategories.Contains(category)"
                                                   @onchange="@(e => ToggleCategory(category, (bool)e.Value!))" />
                                            <label class="form-check-label" for="cat-@category">
                                                @GetCategoryDisplayName(category)
                                            </label>
                                        </div>
                                    </div>
                                }
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        }
        
        <div class="row mb-3">
            <div class="col-md-6">
                <button class="btn btn-warning w-100" @onclick="DeleteInvisibleCharacters" disabled="@(!HasInvisibleCharactersInEnabledCategories)">
                    Clean Selected (@InvisibleCharacterCount)
                </button>
            </div>
            <div class="col-md-6 d-flex align-items-center justify-content-md-end">
                <span class="text-muted small">Highlights are color-coded by category.</span>
            </div>
        </div>

        @if (!string.IsNullOrEmpty(LastCleaningReport))
        {
            <div class="cleaning-report @(LastCleaningHasError ? "error" : "")">
                @LastCleaningReport
                @if (CanUndo)
                {
                    <button class="btn btn-sm btn-outline-secondary ms-2" @onclick="UndoLastCleaning">Undo</button>
                }
            </div>
        }
    </div>

    <!-- Existing Controls -->
    <div>
        <div class="mb-2">
            <button class="btn btn-secondary" @onclick='() => ToggleMarkdownAction("**")' style="font-weight: bold;">B</button>
            <button class="btn btn-secondary" @onclick='() => ToggleMarkdownAction("_")' style="font-style: italic;">I</button>
            <button class="btn btn-secondary" @onclick='() => ToggleMarkdownAction("~~")' style="text-decoration: line-through;">S</button>
            <button class="btn btn-secondary" @onclick='() => ToggleMarkdownAction("`")' style="font-family: monospace;">`code`</button>
            <button class="btn btn-info ms-3" @onclick="LoadExample" title="Load compact text with invisible characters for testing">Show Example</button>
        </div>
    </div>

    <div class="d-flex" style="height: calc(100vh - 200px);">
        <div class="form-group" style="width: 50%; margin-right: 1rem; display: flex; flex-direction: column;">
            <label for="markdownInput" class="form-label">Markdown Content</label>
            <textarea id="markdownInput" class="form-control" style="flex-grow: 1; resize: none;" @ref="MarkdownTextArea" @oninput="OnInput">@MarkdownContent</textarea>
        </div>

        <div class="form-group" style="width: 50%; display: flex; flex-direction: column;">
            <label class="form-label">@(CurrentViewMode == ViewMode.Preview ? "Preview" : "Text with Invisible Characters")</label>
            <div id="preview" class="form-control" style="flex-grow: 1; overflow-y: auto; white-space: pre-wrap;">
                @if (CurrentViewMode == ViewMode.InvisibleCharacters)
                {
                    @((MarkupString)VisualizedPreview)
                }
                else
                {
                    @((MarkupString)MarkdownPreview)
                }
            </div>
        </div>
    </div>

    <div class="d-flex align-items-center mt-2">
        <a class="btn btn-primary" href="@DownloadUrl" download="ExportedDocument.doc">Download as Word</a>
        <p class="text-primary ms-3" style="font-style: italic;">All processing is done entirely in your browser, and no data is transmitted to any server.</p>
    </div>
</div>

@code {
    private enum ViewMode
    {
        Preview,
        InvisibleCharacters
    }

    private ElementReference MarkdownTextArea;
    private string MarkdownContent { get; set; } = string.Empty;
    private string MarkdownPreview { get; set; } = string.Empty;
    private string VisualizedPreview { get; set; } = string.Empty;
    private string DownloadUrl { get; set; } = string.Empty;
    private Markdig.MarkdownPipeline MarkdownPipeline =
        new Markdig.MarkdownPipelineBuilder()
        .UseEmphasisExtras()
        .Build();

    private ViewMode CurrentViewMode { get; set; } = ViewMode.Preview;
    private bool ShowInvisibleCharacters => CurrentViewMode == ViewMode.InvisibleCharacters;
    private HashSet<InvisibleCharacterCategory> EnabledCategories { get; set; } = new();

    private bool HasInvisibleCharactersInEnabledCategories
    {
        get
        {
            if (string.IsNullOrEmpty(MarkdownContent) || EnabledCategories.Count == 0)
                return false;

            var detectionResult = CharacterDetector.DetectInvisibleCharacters(MarkdownContent);
            return detectionResult.DetectedCharacters.Any(dc => EnabledCategories.Contains(dc.Category));
        }
    }
    
    private int InvisibleCharacterCount
    {
        get
        {
            if (string.IsNullOrEmpty(MarkdownContent) || EnabledCategories.Count == 0)
                return 0;

            var detectionResult = CharacterDetector.DetectInvisibleCharacters(MarkdownContent);
            return detectionResult.DetectedCharacters.Count(dc => EnabledCategories.Contains(dc.Category));
        }
    }
    
    private CleaningPreset SelectedPreset { get; set; } = CleaningPreset.Safe;
    private string LastCleaningReport { get; set; } = string.Empty;
    private bool LastCleaningHasError { get; set; } = false;
    private bool CanUndo { get; set; } = false;
    private string? UndoContent { get; set; }

    // Visualization options
    private VisualizationOptions VisualizationOptions => new()
    {
        ShowInvisibleCharacters = ShowInvisibleCharacters,
        SkipCodeBlocks = true,
        ShowLineBreaks = true,
        EnabledCategories = EnabledCategories
    };

    protected override async Task OnInitializedAsync()
    {
        base.OnInitialized();
        PageTitleService.SetTitle("Markdown to Word");
        
        EnabledCategories = Enum.GetValues<InvisibleCharacterCategory>().ToHashSet();
        
        await UpdatePreview();
    }

    private async Task CleanText()
    {
        try
        {
            var cleaningResult = CharacterCleaner.CleanText(MarkdownContent, SelectedPreset);
            
            if (cleaningResult.HasChanges)
            {
                // Cache content for undo
                UndoContent = MarkdownContent;
                CanUndo = true;

                // Apply cleaned text
                MarkdownContent = cleaningResult.CleanedText;
                LastCleaningReport = cleaningResult.Summary;
                LastCleaningHasError = false;

                // Update the textarea
                await JSRuntime.InvokeVoidAsync("updateTextAreaContent", MarkdownTextArea, MarkdownContent);

                await UpdatePreview();
            }
            else
            {
                LastCleaningReport = "No invisible characters found to clean.";
                LastCleaningHasError = false;
                CanUndo = false;
            }
        }
        catch (Exception ex)
        {
            LastCleaningReport = $"Error during cleaning: {ex.Message}";
            LastCleaningHasError = true;
            CanUndo = false;
        }
        
        StateHasChanged();
    }

    private async Task UndoLastCleaning()
    {
        if (CanUndo && UndoContent != null)
        {
            MarkdownContent = UndoContent;
            UndoContent = null;
            CanUndo = false;
            LastCleaningReport = "Cleaning undone.";
            LastCleaningHasError = false;
            
            await JSRuntime.InvokeVoidAsync("updateTextAreaContent", MarkdownTextArea, MarkdownContent);
            await UpdatePreview();
            StateHasChanged();
        }
    }

    private async Task ToggleMarkdownAction(string markdownSymbol)
    {
        var selectionStart = await JSRuntime.InvokeAsync<int>("getSelectionStart", MarkdownTextArea);
        var selectionEnd = await JSRuntime.InvokeAsync<int>("getSelectionEnd", MarkdownTextArea);

        if (selectionStart >= 0 && selectionEnd > selectionStart)
        {
            MarkdownContent = MarkdownProcessor.ToggleMarkdown(MarkdownContent, selectionStart, selectionEnd, markdownSymbol);

            // Update the textarea content explicitly
            await JSRuntime.InvokeVoidAsync("updateTextAreaContent", MarkdownTextArea, MarkdownContent);

            // Update preview
            await UpdatePreview();
        }
    }

    private async Task OnInput(ChangeEventArgs e)
    {
        MarkdownContent = e.Value?.ToString() ?? string.Empty;
        await UpdatePreview();
    }

    private Task UpdatePreview()
    {
        MarkdownPreview = Markdig.Markdown.ToHtml(MarkdownContent, MarkdownPipeline);
        
        if (CurrentViewMode == ViewMode.InvisibleCharacters)
        {
            // Generate visualized preview with only enabled categories
            var visualizedMarkdown = CharacterVisualizer.VisualizeInvisibleCharacters(MarkdownContent, VisualizationOptions);
            VisualizedPreview = Markdig.Markdown.ToHtml(visualizedMarkdown, MarkdownPipeline);
        }
        else
        {
            VisualizedPreview = MarkdownPreview;
        }
        
        GenerateDownloadUrl();
        return Task.CompletedTask;
    }

    private void GenerateDownloadUrl()
    {
        string htmlContent = Markdig.Markdown.ToHtml(MarkdownContent, MarkdownPipeline); // Convert Markdown to HTML

        // Wrap HTML content into a basic Word file structure
        string wordContent = $@"<html xmlns:o='urn:schemas-microsoft-com:office:office'
                            xmlns:w='urn:schemas-microsoft-com:office:word'
                            xmlns='http://www.w3.org/TR/REC-html40'>
<head><meta charset='utf-8'></head>
<body>{htmlContent}</body>
</html>";

        // Convert the content to base64 string
        var byteArray = Encoding.UTF8.GetBytes(wordContent);
        DownloadUrl = "data:application/msword;base64," + Convert.ToBase64String(byteArray);
    }

    private async Task SetViewMode(ViewMode mode)
    {
        CurrentViewMode = mode;
        await UpdatePreview();
        StateHasChanged();
    }

    private async Task ToggleCategory(InvisibleCharacterCategory category, bool enabled)
    {
        if (enabled)
        {
            EnabledCategories.Add(category);
        }
        else
        {
            EnabledCategories.Remove(category);
        }
        
        await UpdatePreview();
        StateHasChanged();
    }

    private async Task DeleteInvisibleCharacters()
    {
        if (!HasInvisibleCharactersInEnabledCategories)
            return;

        try
        {
            // Cache content for undo
            UndoContent = MarkdownContent;

            // Detect invisible characters in the current content
            var detectionResult = CharacterDetector.DetectInvisibleCharacters(MarkdownContent);

            // Collect characters from enabled categories only
            var charactersToRemove = detectionResult.DetectedCharacters
                .Where(dc => EnabledCategories.Contains(dc.Category))
                .OrderByDescending(dc => dc.Position) // Remove from the end to preserve positions
                .ToList();

            // Remove characters
            var cleanedText = MarkdownContent;
            int removedCount = 0;
            var removedCategories = new Dictionary<InvisibleCharacterCategory, int>();
            
            foreach (var charToRemove in charactersToRemove)
            {
                if (charToRemove.Position < cleanedText.Length)
                {
                    cleanedText = cleanedText.Remove(charToRemove.Position, 1);
                    removedCount++;
                    
                    if (!removedCategories.ContainsKey(charToRemove.Category))
                        removedCategories[charToRemove.Category] = 0;
                    removedCategories[charToRemove.Category]++;
                }
            }
            
            MarkdownContent = cleanedText;
            
            await JSRuntime.InvokeVoidAsync("updateTextAreaContent", MarkdownTextArea, MarkdownContent);
            await UpdatePreview();
            
            // Form report
            var categoryReports = removedCategories.Select(kvp => 
                $"{GetCategoryDisplayName(kvp.Key)}: {kvp.Value}");
            LastCleaningReport = $"Removed {removedCount} characters. {string.Join(", ", categoryReports)}";
            LastCleaningHasError = false;
            CanUndo = true;
        }
        catch (Exception ex)
        {
            LastCleaningReport = $"Error during removal: {ex.Message}";
            LastCleaningHasError = true;
            CanUndo = false;
        }
        
        StateHasChanged();
    }

    private string GetCategoryDisplayName(InvisibleCharacterCategory category)
    {
        return category switch
        {
            InvisibleCharacterCategory.C0C1Controls => "C0/C1 Controls",
            InvisibleCharacterCategory.LineBreaks => "Line Breaks", 
            InvisibleCharacterCategory.Tab => "Tab",
            InvisibleCharacterCategory.WideSpaces => "Wide Spaces",
            InvisibleCharacterCategory.NoBreakSpaces => "No-Break Spaces",
            InvisibleCharacterCategory.ZeroWidthFormat => "Zero Width Format",
            InvisibleCharacterCategory.BiDiControls => "BiDi Controls",
            InvisibleCharacterCategory.SoftHyphen => "Soft Hyphen",
            InvisibleCharacterCategory.InvisibleMath => "Invisible Math",
            InvisibleCharacterCategory.VariationSelectors => "Variation Selectors",
            InvisibleCharacterCategory.EmojiTags => "Emoji Tags",
            InvisibleCharacterCategory.CombiningMarks => "Combining Marks",
            InvisibleCharacterCategory.Confusables => "Confusables",
            _ => category.ToString()
        };
    }

    private async Task LoadExample()
    {
        // Store current content for undo if there's content
        if (!string.IsNullOrEmpty(MarkdownContent))
        {
            UndoContent = MarkdownContent;
            CanUndo = true;
        }

        // Generate demo text with various invisible characters
        var demoContent = InvisibleUnicodeDemoGenerator.BuildMarkdown();
        MarkdownContent = demoContent;

        await JSRuntime.InvokeVoidAsync("updateTextAreaContent", MarkdownTextArea, MarkdownContent);
        await UpdatePreview();
        
        LastCleaningReport = "Compact demo text loaded with invisible characters for testing.";
        LastCleaningHasError = false;
        
        StateHasChanged();
    }
}
