@page "/mazerunnerdemo"

@using Demo.Components
@using Demo.Demos.Common
@using Demo.Demos.MazeRunner
@using Demo.Services
@using DimonSmart.MazeGenerator
@using System.Linq
@using System.Text
@using Microsoft.SemanticKernel
@using Microsoft.SemanticKernel.Services
@using Microsoft.SemanticKernel.ChatCompletion
@using Microsoft.SemanticKernel.Agents
@using Microsoft.Extensions.DependencyInjection
@inject PageTitleService PageTitleService
@inject LogStore LogStore
@inject IOllamaModelService OllamaModelService
@inject IOllamaConfigurationProvider OllamaConfigurationProvider
@inject UserPreferencesStorageService<MazeRunnerUserPreferences> UserPreferencesStorageService

@implements IMazePlotter

<link rel="stylesheet" href="css/demos.css" />
<PageTitle>Maze Generator Demo</PageTitle>

<div class="page-container maze-runner-container" style="display: flex;">
    <section style="flex: 1; overflow-y: auto; padding: 20px;">
        <div style="text-align: center; border: 1px solid #ccc; padding: 10px;">
            <div style="margin-bottom: 10px;">
                <label for="mazeSeed">Maze seed:</label>
                <input id="mazeSeed"
                       type="number"
                       min="0"
                       value="@_mazeSeed"
                       @onchange="OnMazeSeedChanged" />
                <button type="button" @onclick="RegenerateMazeWithCurrentSeed">Regenerate</button>
            </div>
            <div>
                <label for="connectionType">Connection Type:</label>
                <select id="connectionType" @onchange="OnConnectionTypeChanged" value="@_connectionType">
                    <option value="ollama">Ollama</option>
                    <option value="openai">OpenAI</option>
                </select>
            </div>

            @if (_connectionType == "ollama")
            {
                <div style="margin-top: 10px;">
                    <label for="ollamaServerUrl">Ollama Server URL:</label>
                    <input id="ollamaServerUrl"
                           type="text"
                           @bind="_ollamaServerUrl"
                           @bind:event="oninput"
                           @onblur="OnOllamaConfigChanged"
                           placeholder="http://localhost:11434" />
                </div>
                <div style="margin-top: 10px;">
                    <label for="ollamaPassword">Ollama Password (optional):</label>
                    <input id="ollamaPassword"
                           type="password"
                           @bind="_ollamaPassword"
                           @bind:event="oninput"
                           @onblur="OnOllamaConfigChanged"
                           placeholder="Enter password if required" />
                </div>
                <div style="margin-top: 10px;">
                    <input id="ignoreSslErrors"
                           type="checkbox"
                           @bind="_ignoreSslErrors"
                           @bind:after="OnSslSettingChanged" />
                    <label for="ignoreSslErrors">Ignore SSL certificate errors</label>
                </div>

                @if (AvailableModels != null && AvailableModels.Count > 0)
                {
                    <div style="margin-top:10px;">
                        <label for="modelSelect">Select Ollama Model:</label>
                        <select id="modelSelect" @onchange="OnModelChanged" value="@SelectedModelId">
                            @foreach (var model in AvailableModels)
                            {
                                <option value="@model.ModelId">
                                    @model.ModelId (@model.ParameterCount, @((model.Size / 1024.0 / 1024.0).ToString("F2")) MB)
                                </option>
                            }
                        </select>
                    </div>
                }
                else
                {
                    <div style="margin-top:10px;">
                        <h4>Installing and Configuring ollama</h4>
                        <p>No models were found. To get started with ollama, please follow these steps:</p>
                        <ol style="text-align: left; display: inline-block;">
                            <li>
                                Download and install ollama from the official website:
                                <a href="https://ollama.com" target="_blank">https://ollama.com</a>.
                            </li>
                            <li>
                                Run ollama and download the required models (for example, using the command
                                <code>ollama pull &lt;model-id&gt;</code>).
                            </li>
                            <li>
                                To allow web access to local Ollama, set the environment variable:<br/>
                                <code>OLLAMA_ORIGINS=https://dimonsmart.is-a.dev</code><br/>
                                (or use <code>*</code> to allow all origins: <code>OLLAMA_ORIGINS=*</code>)<br/>
                                Restart Ollama after setting this variable.
                            </li>
                            <li>Make sure the server URL and password (if required) are correct.</li>
                            <li>Restart the application to apply the changes.</li>
                        </ol>
                    </div>
                }
            }
            else if (_connectionType == "openai")
            {
                <div style="margin-top: 10px;">
                    <label for="openaiKey">OpenAI API Key (will be masked):</label>
                    <input id="openaiKey"
                           type="password"
                           @bind="_openAIApiKey"
                           @bind:event="oninput"
                           @onblur="SaveSettings"
                           placeholder="Enter OpenAI API key" />
                </div>
                <div style="margin-top: 10px;">
                    <label for="openaiModel">OpenAI Model (e.g., gpt-3.5-turbo):</label>
                    <input id="openaiModel"
                           type="text"
                           @bind="_openAIModel"
                           @bind:event="oninput"
                           @onblur="SaveSettings"
                           placeholder="Enter OpenAI Model" />
                </div>
                <div style="margin-top: 10px;">
                    <input id="ignoreSslErrorsOpenAI"
                           type="checkbox"
                           @bind="_ignoreSslErrors"
                           @bind:after="OnSslSettingChanged" />
                    <label for="ignoreSslErrorsOpenAI">Ignore SSL certificate errors</label>
                </div>
            }
        </div>

        @if (_maze != null)
        {
            <div style="margin-top: 20px; display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; align-items: flex-start;">
                <div style="flex: 1 1 300px;">
                    <div style="display: flex; justify-content: center;">
                        <CascadingValue Value="_maze.Robot">
                            <MazeDisplay TCell="MazeRunnerCellModel" Maze="_maze">
                                <CellTemplate Context="cell">
                                    <MazeRunnerCell X="@cell.X" Y="@cell.Y" Cell="@cell.Cell" />
                                </CellTemplate>
                            </MazeDisplay>
                        </CascadingValue>
                    </div>
                </div>

                <div style="flex: 0 0 auto;">
                    <Joystick Width="150px" Height="150px"
                              OnUpClicked="OnUpClicked"
                              OnDownClicked="OnDownClicked"
                              OnLeftClicked="OnLeftClicked"
                              OnRightClicked="OnRightClicked" />
                </div>
            </div>

            <div class="recorder-controls-container">
                <div class="recorder-controls">
                    <button class="magneto-button record-button @GetRecordButtonClass()"
                            @onclick="ToggleRecording"
                            disabled="@(_maze == null || _isPlaybackInProgress || _recordingState == RecordingState.Stopping)">
                        <span class="icon"></span>
                    </button>
                    <button class="magneto-button play-button"
                            @onclick="PlayRecording"
                            disabled="@(!_recordedSnapshots.Any() || _recordingState != RecordingState.Idle || _isPlaybackInProgress || IsProcessingCommand)">
                        <span class="play-icon">&#9658;</span>
                    </button>
                    <label class="frame-duration-label">
                        Frame (ms):
                        <input type="number" min="0" step="50" @bind="FrameDurationMs" @bind:event="oninput" />
                    </label>
                </div>
                @if (_recordingState == RecordingState.Recording)
                {
                    <div class="recording-indicator">
                        <span class="indicator-dot"></span>
                        Recording...
                    </div>
                }
                @if (_isPlaybackInProgress)
                {
                    <div class="playback-indicator">Playback in progress...</div>
                }
            </div>

            <div style="margin-top: 20px; text-align: center; border: 1px solid #ccc; padding: 10px;">
                <input type="text" @bind="UserCommand" placeholder="Enter command (e.g., 'move right')" style="width:300px;" />
                <button @onclick="ProcessUserCommand" disabled="@(IsProcessingCommand || _isPlaybackInProgress)">Send Command</button>
                @if (IsProcessingCommand)
                {
                    <Spinner />
                }
                <div style="margin-top:10px;">
                    <strong>Assistant's response:</strong> @ResponseMessage
                </div>
            </div>

            <div style="margin-top: 20px; border: 1px solid #ccc; padding: 10px;">
                <h4>System Prompt Editor</h4>
                <p style="font-size: 0.9em; color: #666;">Edit the system prompt that controls the robot's behavior:</p>
                <textarea @bind="_systemPrompt" 
                          @bind:event="oninput"
                          style="width: 100%; min-height: 200px; font-family: monospace; font-size: 0.9em; padding: 8px;"
                          placeholder="Enter system prompt..."></textarea>
                <div style="margin-top: 10px;">
                    <button @onclick="ResetSystemPrompt">Reset to Default</button>
                </div>
            </div>
        }
    </section>

    <section style="min-width: 200px; width: 33%; border-left: 1px solid #ccc; height: 100%; overflow-y: auto;">
        <LogView LogMessages="@LogStore.Messages" />
    </section>
</div>

@code {
    private const int MaxRobotStepsPerSession = 1000;
    private const int DefaultMazeSeed = 1;

    protected int XSize = 9;
    protected int YSize = 9;
    protected MazeRunnerMaze? _maze;

    private bool IsProcessingCommand = false;
    private string UserCommand { get; set; } = "";
    private string ResponseMessage { get; set; } = "";

    private IReadOnlyList<OllamaModelInfo> AvailableModels { get; set; } = new List<OllamaModelInfo>();
    private string SelectedModelId { get; set; } = "";

    private const string DefaultConnectionType = "ollama";
    private string _connectionType = DefaultConnectionType;
    private string _openAIApiKey = "";
    private string _openAIModel = "gpt-4.0-mini";
    private string _ollamaServerUrl = "http://localhost:11434";
    private string _ollamaPassword = "";
    private bool _ignoreSslErrors = false;
    private int _mazeSeed = DefaultMazeSeed;
    private string _systemPrompt = "";

    private RecordingState _recordingState = RecordingState.Idle;
    private readonly List<MazeSnapshot> _recordedSnapshots = new();
    private MazeSnapshot? _lastRecordedSnapshot;
    private bool _isPlaybackInProgress;
    private int _frameDurationMs = 500;

    private int FrameDurationMs
    {
        get => _frameDurationMs;
        set => _frameDurationMs = Math.Max(0, value);
    }

    protected override async Task OnInitializedAsync()
    {
        PageTitleService.SetTitle("Maze runner");
        var preferences = await UserPreferencesStorageService.LoadPreferencesAsync();
        if (preferences != null)
        {
            if (!string.IsNullOrEmpty(preferences.SelectedModelId))
                SelectedModelId = preferences.SelectedModelId;
            if (!string.IsNullOrEmpty(preferences.ConnectionType))
                _connectionType = preferences.ConnectionType;
            if (!string.IsNullOrEmpty(preferences.OpenAIApiKey))
                _openAIApiKey = preferences.OpenAIApiKey;
            if (!string.IsNullOrEmpty(preferences.OpenAIModel))
                _openAIModel = preferences.OpenAIModel;
            if (!string.IsNullOrEmpty(preferences.OllamaServerUrl))
                _ollamaServerUrl = preferences.OllamaServerUrl;
            if (!string.IsNullOrEmpty(preferences.OllamaPassword))
                _ollamaPassword = preferences.OllamaPassword;
            _ignoreSslErrors = preferences.IgnoreSslErrors;
            _mazeSeed = NormalizeSeed(preferences.MazeSeed);
        }
        else
        {
            _mazeSeed = DefaultMazeSeed;
        }

        GenerateMaze();

        AvailableModels = await OllamaModelService.GetLoadedModelsAsync();

        if (preferences == null && AvailableModels.Count > 0)
            SelectedModelId = AvailableModels[0].ModelId;

        _systemPrompt = DefaultSystemPrompts.GetMazeRunnerPrompt();

        StateHasChanged();
    }

    private void GenerateMaze()
    {
        _maze = new MazeRunnerMaze(XSize, YSize);
        var options = new DimonSmart.MazeGenerator.MazeBuildOptions(0, 0);
        _mazeSeed = NormalizeSeed(_mazeSeed);
        var random = new Random(_mazeSeed);
        var mazeBuilder = new MazeBuilder<MazeRunnerCellModel>(_maze, options, random);
        mazeBuilder.Build(this, CancellationToken.None);
    }

    private static int NormalizeSeed(int seed) => seed < 0 ? Math.Abs(seed) : seed;

    private async Task OnMazeSeedChanged(ChangeEventArgs e)
    {
        if (e.Value is null)
        {
            StateHasChanged();
            return;
        }

        if (!int.TryParse(e.Value.ToString(), out var seed))
        {
            StateHasChanged();
            return;
        }

        seed = NormalizeSeed(seed);

        if (seed == _mazeSeed)
        {
            return;
        }

        _mazeSeed = seed;
        await RegenerateMazeAsync($"Maze seed changed: {_mazeSeed}");
    }

    private async Task RegenerateMazeWithCurrentSeed()
    {
        await RegenerateMazeAsync($"Maze regenerated with seed {_mazeSeed}");
    }

    private async Task RegenerateMazeAsync(string? logMessage = null)
    {
        GenerateMaze();

        if (!string.IsNullOrWhiteSpace(logMessage))
        {
            LogStore.Messages.Add(new LogStore.LogMessage(logMessage, LogStore.LogType.UserInput));
        }

        await SaveSettings();
        StateHasChanged();
    }

    async Task IMazePlotter.PlotWallAsync(int x, int y)
    {
        StateHasChanged();
        await Task.Delay(50);
    }

    #region Joystick event handlers
    private void OnUpClicked() => HandleManualMove(robot => robot.MoveUp(), "up");

    private void OnDownClicked() => HandleManualMove(robot => robot.MoveDown(), "down");

    private void OnLeftClicked() => HandleManualMove(robot => robot.MoveLeft(), "left");

    private void OnRightClicked() => HandleManualMove(robot => robot.MoveRight(), "right");

    private void HandleManualMove(Func<Robot, string> moveFunc, string direction)
    {
        if (_maze == null || _isPlaybackInProgress)
        {
            return;
        }

        var result = moveFunc(_maze.Robot);
        LogStore.Messages.Add(new LogStore.LogMessage($"Manual move {direction}: {result}", LogStore.LogType.RobotMovements));

        if (result == "Ok")
        {
            RecordSnapshot();
        }

        StateHasChanged();
    }

    private async Task ToggleRecording()
    {
        if (_maze == null || _isPlaybackInProgress || _recordingState == RecordingState.Stopping)
        {
            return;
        }

        if (_recordingState == RecordingState.Idle)
        {
            StartRecording();
            StateHasChanged();
            return;
        }

        if (_recordingState == RecordingState.Recording)
        {
            await StopRecordingAsync();
        }
    }

    private void StartRecording()
    {
        if (_maze == null)
        {
            return;
        }

        _recordedSnapshots.Clear();
        _lastRecordedSnapshot = null;
        _recordingState = RecordingState.Recording;
        RecordSnapshot(force: true);
    }

    private async Task StopRecordingAsync()
    {
        if (_recordingState != RecordingState.Recording)
        {
            return;
        }

        _recordingState = RecordingState.Stopping;
        StateHasChanged();
        await Task.Yield();

        RecordSnapshot(force: true);

        _recordingState = RecordingState.Idle;
        StateHasChanged();
    }

    private async Task PlayRecording()
    {
        if (_maze == null || _isPlaybackInProgress || _recordedSnapshots.Count == 0 || _recordingState != RecordingState.Idle || IsProcessingCommand)
        {
            return;
        }

        _isPlaybackInProgress = true;
        StateHasChanged();

        try
        {
            var snapshots = _recordedSnapshots.ToList();

            foreach (var snapshot in snapshots)
            {
                ApplySnapshot(snapshot);
                StateHasChanged();

                var delay = FrameDurationMs;
                if (delay > 0)
                {
                    await Task.Delay(delay);
                }
            }
        }
        finally
        {
            _isPlaybackInProgress = false;
            StateHasChanged();
        }
    }

    private string GetRecordButtonClass() => _recordingState switch
    {
        RecordingState.Idle => "record-ready",
        RecordingState.Recording => "record-active",
        RecordingState.Stopping => "record-stopping",
        _ => "record-ready"
    };

    private void RecordSnapshot(bool force = false)
    {
        if (_maze == null)
        {
            return;
        }

        if (!force && _recordingState != RecordingState.Recording)
        {
            return;
        }

        var snapshot = MazeSnapshot.FromMaze(_maze);

        if (_lastRecordedSnapshot != null && _lastRecordedSnapshot == snapshot)
        {
            return;
        }

        _recordedSnapshots.Add(snapshot);
        _lastRecordedSnapshot = snapshot;
    }

    private void ApplySnapshot(MazeSnapshot snapshot)
    {
        if (_maze == null)
        {
            return;
        }

        _maze.GoalAchieved = snapshot.GoalAchieved;
        _maze.Robot.SetPosition(snapshot.RobotX, snapshot.RobotY);
    }

    private Task OnMazeStateChangedAsync()
    {
        return InvokeAsync(() =>
        {
            if (_maze == null)
            {
                return;
            }

            RecordSnapshot();
            StateHasChanged();
        });
    }
    #endregion

    private async Task ProcessUserCommand()
    {
        if (IsProcessingCommand || _isPlaybackInProgress) return;

        IsProcessingCommand = true;
        StateHasChanged();

        try
        {
            var kernel = GetKernel();
            var response = await ExecuteChatCompletion(kernel);
            ResponseMessage = response;
            LogStore.Messages.Add(new LogStore.LogMessage($"Semantic: {ResponseMessage}", LogStore.LogType.SemanticKernel));
        }
        catch (Exception ex)
        {
            HandleError("An error occurred", ex);
        }
        finally
        {
            IsProcessingCommand = false;
            StateHasChanged();
        }
    }

    private Kernel GetKernel()
    {
        if (_maze == null)
            throw new InvalidOperationException("Maze is not initialized");

        var kernelBuildParameters = new KernelBuildParameters(_maze, _connectionType, SelectedModelId, _openAIModel, true, _openAIApiKey, LogStore, _ollamaServerUrl, _ollamaPassword, _ignoreSslErrors, OnMazeStateChangedAsync);
        return KernelFactory.BuildKernel(kernelBuildParameters);
    }

    private async Task<string> ExecuteChatCompletion(Kernel kernel)
    {
        if (_maze == null)
        {
            return "Maze is not initialized.";
        }

        _maze.CommandHistory.Clear();
        _maze.GoalAchieved = false;

        var systemPrompt = BuildSystemPrompt();

        var executionSettings = new PromptExecutionSettings
        {
            FunctionChoiceBehavior = FunctionChoiceBehavior.Auto()
        };

        var recordedSteps = new List<string>();
        var processedCount = 0;
        var movesIssued = 0;
        string? lastAssistantMessage = null;

        var agent = CreateMazeRunnerAgent(kernel, systemPrompt, executionSettings);

        while (movesIssued < MaxRobotStepsPerSession)
        {
            var userPrompt = BuildIterationPrompt(recordedSteps, MaxRobotStepsPerSession - movesIssued);
            var messages = new List<ChatMessageContent>
            {
                new(AuthorRole.User, userPrompt)
            };

            var responses = agent.InvokeAsync(messages);
            await foreach (var responseItem in responses)
            {
                if (responseItem.Message != null && !string.IsNullOrWhiteSpace(responseItem.Message.Content))
                {
                    lastAssistantMessage = responseItem.Message.Content;
                }
            }

            if (_maze.CommandHistory.Count <= processedCount)
            {
                return lastAssistantMessage ?? "The assistant did not issue a command.";
            }

            var newSteps = _maze.CommandHistory.Skip(processedCount).ToList();
            processedCount = _maze.CommandHistory.Count;
            recordedSteps.AddRange(newSteps);
            movesIssued += newSteps.Count;

            StateHasChanged();

            if (_maze.GoalAchieved)
            {
                return lastAssistantMessage ?? $"Goal reported after {movesIssued} move(s).";
            }
        }

        if (_maze.GoalAchieved)
        {
            return lastAssistantMessage ?? "The robot reported completion.";
        }

        if (lastAssistantMessage != null)
        {
            return $"{lastAssistantMessage} (controller stopped after {movesIssued} move(s) without completion).";
        }

        return $"Step limit reached ({MaxRobotStepsPerSession}) without completing the goal.";
    }

    private string BuildSystemPrompt()
    {
        return _systemPrompt;
    }

    private void ResetSystemPrompt()
    {
        _systemPrompt = DefaultSystemPrompts.GetMazeRunnerPrompt();
        StateHasChanged();
    }

    private string BuildIterationPrompt(IReadOnlyList<string> commandHistory, int remainingSteps)
    {
        if (_maze == null)
        {
            return "Maze is not initialized.";
        }

        var builder = new StringBuilder();
        builder.AppendLine($"Goal: {UserCommand}");
        builder.AppendLine("Previous steps:");

        if (commandHistory.Count == 0)
        {
            builder.AppendLine("None so far.");
        }
        else
        {
            for (var i = 0; i < commandHistory.Count; i++)
            {
                builder.AppendLine($"{i + 1}. {commandHistory[i]}");
            }
        }

        builder.AppendLine();
        builder.AppendLine("Current maze state:");
        builder.AppendLine(_maze.MakeMazeAsTextRepresentation());
        builder.AppendLine("Plan and call exactly one function: MazeRunnerRobotPlugin_MoveUp, MazeRunnerRobotPlugin_MoveDown, MazeRunnerRobotPlugin_MoveLeft, MazeRunnerRobotPlugin_MoveRight, or MazeRunnerRobotPlugin_ReportGoalReached. Provide a short justification in natural language after issuing the function call.");

        return builder.ToString();
    }

    private void HandleError(string userMessage, Exception ex)
    {
        ResponseMessage = userMessage;
        LogStore.Messages.Add(new LogStore.LogMessage($"Error: {ex.Message}", LogStore.LogType.SemanticKernel));
        if (ex.InnerException != null)
        {
            LogStore.Messages.Add(new LogStore.LogMessage($"Inner exception: {ex.InnerException.Message}", LogStore.LogType.SemanticKernel));
        }
    }

    private async Task OnModelChanged(ChangeEventArgs e)
    {
        SelectedModelId = e.Value?.ToString() ?? "";
        await SaveSettings();
        LogStore.Messages.Add(new LogStore.LogMessage($"Selected Ollama model changed: {SelectedModelId}", LogStore.LogType.UserInput));
        StateHasChanged();
    }

    private async Task OnConnectionTypeChanged(ChangeEventArgs e)
    {
        _connectionType = e.Value?.ToString() ?? DefaultConnectionType;
        await SaveSettings();
        LogStore.Messages.Add(new LogStore.LogMessage($"Connection type changed: {_connectionType}", LogStore.LogType.UserInput));
        StateHasChanged();
    }

    private async Task OnOllamaConfigChanged()
    {
        AvailableModels = await OllamaModelService.GetLoadedModelsAsync();
        
        await SaveSettings();
        LogStore.Messages.Add(new LogStore.LogMessage($"Ollama configuration updated: {_ollamaServerUrl}", LogStore.LogType.UserInput));
        StateHasChanged();
    }

    private async Task OnSslSettingChanged()
    {
        await SaveSettings();
        LogStore.Messages.Add(new LogStore.LogMessage($"SSL setting changed: Ignore SSL errors = {_ignoreSslErrors}", LogStore.LogType.UserInput));
        StateHasChanged();
    }

    private async Task SaveSettings()
    {
        var preferences = new MazeRunnerUserPreferences
        {
            SelectedModelId = SelectedModelId,
            ConnectionType = _connectionType,
            OpenAIApiKey = _openAIApiKey,
            OpenAIModel = _openAIModel,
            OllamaServerUrl = _ollamaServerUrl,
            OllamaPassword = _ollamaPassword,
            IgnoreSslErrors = _ignoreSslErrors,
            MazeSeed = _mazeSeed
        };
        await UserPreferencesStorageService.SavePreferencesAsync(preferences);
    }

    private static ChatCompletionAgent CreateMazeRunnerAgent(
        Kernel kernel,
        string systemPrompt,
        PromptExecutionSettings executionSettings)
    {
        return new ChatCompletionAgent
        {
            Kernel = kernel,
            Name = "MazeRunnerAgent",
            Instructions = systemPrompt,
            Description = "AI Assistant that controls a robot in a maze",
            Arguments = new KernelArguments(executionSettings)
        };
    }

    private enum RecordingState
    {
        Idle,
        Recording,
        Stopping
    }

    private sealed record MazeSnapshot(int RobotX, int RobotY, bool GoalAchieved, string MazeSignature)
    {
        public static MazeSnapshot FromMaze(MazeRunnerMaze maze) =>
            new(maze.Robot.X, maze.Robot.Y, maze.GoalAchieved, maze.MakeMazeAsTextRepresentation(true));
    }
}
