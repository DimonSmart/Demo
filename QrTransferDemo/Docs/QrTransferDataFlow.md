# QR Transfer Data Flow Analysis

## Обзор
Вкладка **QR Transfer** генерирует последовательность QR-кадров, каждый из которых кодирует бинарный пакет. Пакеты делятся на два типа:

* **Метаданные** — сообщают сведения о файле и подготовительных параметрах.
* **Данные** — несут байты самого файла.

Перед началом передачи данных для выбранного файла всегда отправляется полный поток метаданных. После этого передаются пакеты с данными файла. Каждый файл обслуживается в собственной файловой ячейке (индексы 0–15). Ниже описаны формат кадра, алгоритм отправителя и алгоритм приёмника.

## Формат кадра передачи
Бинарный кадр формируется в `QrTransferSenderTab.SerializePacket` и включает шестибайтный заголовок, за которым следует полезная нагрузка.【F:QrTransferDemo/Components/QrTransferSenderTab.razor.cs†L486-L500】

| Смещение | Размер | Описание |
| --- | --- | --- |
| 0 | 1 | Флаги: бит 7 = 1 для метаданных, 0 = данные; биты 0–3 содержат индекс файла; биты 4–6 зарезервированы и всегда нули. |
| 1 | 1 | Длина полезной нагрузки в байтах (0–255). |
| 2 | 2 | Общая длина соответствующего потока (метаданных или данных) в байтах, little-endian. |
| 4 | 2 | Смещение полезной нагрузки внутри потока в байтах, little-endian. |
| 6 | *N* | Сырые байты полезной нагрузки. |

Перед сериализацией файлы разбиваются на пакеты `QrChunkBuilder.SplitIntoPackets`, что гарантирует соблюдение ограничений заголовка (длина ≤ 255, смещения и длины ≤ 65535).【F:QrTransferDemo/Services/QrChunkBuilder.cs†L33-L73】

## Формат метаданных
Метаданные строятся в `QrChunkBuilder.BuildMetadata` и включают параметры передачи и контрольные суммы CRC-32 для каждого блока размера 256 байт (по умолчанию).【F:QrTransferDemo/Services/QrChunkBuilder.cs†L12-L108】

| Смещение | Размер | Описание |
| --- | --- | --- |
| 0 | 1 | Длина имени файла в UTF-8. |
| 1 | *N* | Имя файла в кодировке UTF-8. |
| 1 + *N* | 2 | Размер файла в байтах (0–65535). |
| 3 + *N* | 1 | Размер чанка, используемый при передаче (в байтах). |
| 4 + *N* | 1 | Уровень коррекции ошибок QR (ASCII-символ или `0`, если не указан). |
| 5 + *N* | 2 | Размер блока для контрольных сумм (по умолчанию 256). |
| 7 + *N* | 2 | Количество блоков контрольных сумм. |
| 9 + *N* | 4 | CRC-32 всего файла (0, если не используется). |
| 13 + *N* | `4 × count` | CRC-32 для каждого блока по `blockSize` байт. |

Алгоритм CRC-32 использует стандартный многочлен `0xEDB88320` и реализован в `Utilities/Crc32`.【F:QrTransferDemo/Utilities/Crc32.cs†L5-L33】

## Алгоритм отправителя
1. Пользователь выбирает файлы; каждый файл получает индекс (0–15) и буфер байтов.
2. `QrChunkBuilder.BuildPackets` создаёт список пакетов: сначала поток метаданных, затем поток данных. Метаданные и данные разбиваются на чанки размера `chunkSize` либо остаток для последнего чанка.【F:QrTransferDemo/Services/QrChunkBuilder.cs†L15-L73】
3. Цикл передачи в `QrTransferSenderTab` извлекает очередной пакет, сериализует его в шестибайтный заголовок + полезную нагрузку и генерирует QR-код через `QrCode.EncodeSegments`.【F:QrTransferDemo/Components/QrTransferSenderTab.razor.cs†L348-L500】
4. Таймер кадра (`_frameDuration`) определяет паузу между QR-кадрами; пустые кадры не генерируются, если очередь пуста.
5. Перед переходом к следующему файлу отправитель убеждается, что все пакеты (метаданные и данные) для текущего файла были показаны.

## Формат кадра приёма
После захвата изображения `QrFrameDecoder.TryDecode` извлекает сырые байты QR-кода. Далее `QrTransferReceiverTab.TryParsePacket` интерпретирует шестибайтный заголовок и полезную нагрузку, проверяя:

* корректность зарезервированных битов;
* совпадение объявленной длины полезной нагрузки с фактической;
* отсутствие выхода за пределы потока (offset + length ≤ totalLength, если totalLength > 0).【F:QrTransferDemo/Components/QrTransferReceiverTab.razor.cs†L372-L413】【F:QrTransferDemo/Components/QrTransferReceiverTab.razor.cs†L538-L571】

Парсер возвращает `QrChunkPacket`, который затем передаётся в сборщик чанков.

## Алгоритм приёмника
1. `QrFrameDecoder.TryDecode` преобразует RGBA-кадр в яркостный буфер ZXing и декодирует QR-код. Если байты получены, они отправляются в `HandleDecodedPayloadAsync`.【F:QrTransferDemo/Services/QrFrameDecoder.cs†L12-L73】【F:QrTransferDemo/Components/QrTransferReceiverTab.razor.cs†L362-L420】
2. `TryParsePacket` проверяет заголовок, отделяет флаги и формирует `QrChunkPacket` для соответствующего файла. Ошибки парсинга фиксируются и отображаются пользователю.【F:QrTransferDemo/Components/QrTransferReceiverTab.razor.cs†L538-L571】
3. `QrChunkAssembler.ProcessChunk` помещает пакет в буфер файла по индексу. Метаданные и данные обрабатываются раздельно:
   * **Метаданные**: байты копируются в буфер. При полном наборе вызывается `TryParseMetadata`, который извлекает все поля, проверяет ограничения (индексы, размер файла, размер чанка) и подготавливает структуры для данных.【F:QrTransferDemo/Services/QrChunkAssembler.cs†L70-L209】
   * **Данные**: проверяются смещения, длина чанка и соответствие заявленному размеру. Пакет копируется в итоговый буфер; дубликаты игнорируются. После получения всех чанков запускается `FinalizeFile`, где проверяются CRC-32 блока и файла. При успехе формируется `AssembledFile`.【F:QrTransferDemo/Services/QrChunkAssembler.cs†L210-L366】
4. Снимок состояния (`FileAssemblySnapshot`) обновляет UI: прогресс, список недостающих чанков, ошибки CRC и т. д.【F:QrTransferDemo/Services/QrChunkAssembler.cs†L22-L69】【F:QrTransferDemo/Services/QrChunkAssembler.cs†L367-L420】

## Сравнение форматов передачи и приёма
* **Заголовок кадра**: отправитель и приёмник используют одинаковый шестибайтный формат (флаги, длина, общая длина, смещение). Отправитель записывает значения в `SerializePacket`, приёмник считывает теми же типами (`byte`, `ushort`) и проверяет длину и границы. Никаких преобразований порядка байт не производится, обе стороны используют little-endian для 16-битных полей.【F:QrTransferDemo/Components/QrTransferSenderTab.razor.cs†L486-L500】【F:QrTransferDemo/Components/QrTransferReceiverTab.razor.cs†L538-L571】
* **Метаданные**: структура байтов, созданная `BuildMetadata`, полностью совпадает с тем, что ожидает `TryParseMetadata`. Имя файла, размеры, уровень коррекции, размер блока и контрольные суммы CRC-32 читаются в той же последовательности и типах на обеих сторонах.【F:QrTransferDemo/Services/QrChunkBuilder.cs†L84-L108】【F:QrTransferDemo/Services/QrChunkAssembler.cs†L126-L209】
* **Чанки данных**: отправитель делит потоки с помощью `SplitIntoPackets`, гарантируя, что последний чанк имеет корректную длину. Приёмник пересчитывает ожидаемую длину по смещению и заявленному размеру, выявляя дубликаты и выход за границы. Данные копируются напрямую без дополнительных преобразований. 【F:QrTransferDemo/Services/QrChunkBuilder.cs†L58-L73】【F:QrTransferDemo/Services/QrChunkAssembler.cs†L210-L301】

Таким образом, форматы передачи и приёма идентичны. Ошибки декодирования, скорее всего, возникают из-за внешних факторов (качество сканирования, повреждённые кадры) либо из-за нарушений ограничений заголовка/метаданных, которые детектирует приёмник и помечает как `InvalidMetadata` или `InvalidFileChecksum`.
