# Планировщик фильтров и действий

## Цели и контекст
- Объединить текущие концепции фильтров и действий вокруг единого планировщика.
- Конечная цель планировщика — построить последовательность фильтров (быстрых и медленных) и затем единый набор действий над всем итоговым множеством билетов. Если запрос пользователя упоминает разные действия для разных условий, такие сценарии сейчас считаются неподдерживаемыми и должны приводить к ошибке планирования.
- Планировщик должен уметь собирать цепочку фильтров, отдающих предикаты для MCP-сервера, и после успешной фильтрации запускать действия над всем отфильтрованным множеством билетов.
- Фильтры делятся на быстрые (конвертация текстового условия в локальный предикат) и медленные (делегирование фильтрации к MCP-серверу/LLM).
- Все операции выполняются внутри контекста сессии пользователя, чтобы фильтры и действия ссылались на один и тот же набор билетов.

## Основные сущности
1. **Контекст планирования**
   - Уникальный идентификатор сессии.
   - Исходный список билетов и текущее «окно» отфильтрованных билетов.
   - Список применённых фильтров с метаданными (тип, источник, эффект).
   - Счётчики промежуточных результатов (оставшиеся билеты, количество отсечённых элементов и т.д.).

2. **Сервис планирования условий и действий**
    - Отдельный компонент, использующий LLM и MCP-сервер для пошагового разбора пользовательского текста в набор условий и итоговых действий.
    - Работает по схеме: LLM формулирует гипотезу условия → вызывает MCP-функцию `TryBuildFastPredicate`.
    - MCP либо возвращает `{ success: true, predicateId, predicateDescriptor }`, либо сообщает, что условие невозможно построить (фатальная ошибка), либо просит переключиться на медленный сценарий (`{ success: false, isFatal: false }`).
    - Если быстрый вариант недоступен, сервис инициирует `TryPlanSlowFilter`, где MCP сообщает, может ли условие быть выполнено внешними средствами, и возвращает дескриптор/идентификатор медленного фильтра.
    - После планирования фильтров сервис обязан определить действия: сначала попытаться построить быстрые действия, а при невозможности — переключиться на медленные (LLM-вызовы). Набор действий должен ссылаться на тот же `contextId`, что и фильтры.
    - LLM получает инструкции не придумывать неподдерживаемые поля и фиксирует в контексте, какой тип фильтра или действия был выбран, чтобы последующие шаги знали, какие MCP-команды ещё доступны.

3. **Быстрый фильтр**
   - Формируется локально функцией «Text → Predicate».
   - Функция возвращает структуру `PredicateBuildResult { bool Success; Predicate? Value; string? FailureReason; bool IsFatal; }`.
   - `IsFatal = true` означает, что условие невозможно интерпретировать (несуществующее поле, неподдерживаемая операция) и планирование нужно завершить с ошибкой, не переходя к медленному сценарию.
   - При `Success = true` предикат добавляется в контекст и применяется к текущему набору билетов.
   - При `Success = false` и `IsFatal = false` планировщик переходит к медленному сценарию для данного условия.

4. **Медленный (LLM) фильтр**
    - Рабочее название — «медленный фильтр», но в промптах его стоит описывать как LLM/Remote filter, чтобы подчеркнуть, что он вычисляется вне локального процесса.
    - Структура запроса к MCP-серверу (LLM) с описанием условия и доступных инструментов.
    - Перед формированием запроса планировщик повторно валидирует условие (например, проверяет наличие ссылок на известные поля) и может сразу вернуть ошибку.
    - В результате сервер возвращает дескриптор фильтра (например, SQL-like условие, список идентификаторов или указание на внешнее вычисление).
    - После получения дескриптора планировщик прикрепляет его к контексту и запускает выполнение через MCP.
    - Если медленный фильтр тоже сообщает, что условие невыполнимо, планировщик завершает с ошибкой и очищает контекст.

5. **Действия**
    - Планировщик должен подготовить список действий, применимых ко всем билетам, оставшимся после фильтрации. Действия делятся на быстрые (мини-C# программа, выполняющаяся локально над каждым билетом) и медленные (описание задачи, которое LLM исполняет через MCP-вызов).
    - Быстрые действия формируются аналогично быстрым фильтрам: MCP-команда проверяет, можно ли синтезировать безопасную мини-программу для одного билета, и возвращает идентификатор/код для исполнения.
    - Медленные действия используют уже существующий код вызова LLM по текстовому описанию. Его потребуется унифицировать с новым планировщиком, чтобы он принимал `contextId` и дескриптор действия.
    - Функция MCP «ExecuteActionForFilteredTickets(contextId, actionDescriptor)» получает ссылку на контекст с накопленными фильтрами и выполняет выбранный тип действия над итоговым набором билетов.

6. **Результат планирования**
    - Планировщик возвращает структуру вида `PlanResult { List<PredicateDescriptor> FastFilters; List<SlowFilterDescriptor> SlowFilters; List<ActionDescriptor> Actions; }`.
    - `PredicateDescriptor` содержит `predicateId`, исходный текст и сведения о применении.
    - `SlowFilterDescriptor` описывает удалённый запрос: тип MCP-команды, параметры и ожидаемый артефакт (например, список идентификаторов, SQL-condition, внешний pipeline).
    - `ActionDescriptor` фиксирует выбранный тип действия (быстрое или медленное), ссылку на код/промпт и требования к ресурсам.
    - Эти структуры должны храниться в `FilterContext`, чтобы выполнение могло повторно применить план без вмешательства LLM.

## Пошаговый сценарий работы
1. **Инициализация**
   - Создать контекст планирования для пользовательского запроса (например, «исправить орфографические ошибки для всех билетов с >5 фото и с ошибками»).
   - Запрос формируется в промпт для LLM: "Ты планировщик..." с перечислением доступных быстрых/медленных фильтров и действий.

2. **Прохождение по условиям фильтрации**
   - LLM-«планировщик» работает в промпте «Ты планировщик...», где перечислены MCP-команды `TryBuildFastPredicate`, `TryPlanSlowFilter`, `ExecuteFilter`, `ExecuteActionForFilteredTickets`.
   - Для каждого условия ("больше пяти картинок", "есть орфографические ошибки") планировщик сначала вызывает MCP `TryBuildFastPredicate`.
   - Успешный ответ возвращает идентификатор предиката, который локальный сервис конвертирует в `Predicate` и применяет через функцию Text→Predicate/fast pipeline.
   - Если `Success = true`, предикат применяется локально, результат фиксируется в контексте.
   - Если `IsFatal = true`, планировщик немедленно возвращает ошибку (например, "поле вес отсутствует") и сообщает пользователю, что запрос невыполним.
   - Если после применения всех быстрых фильтров билетов не осталось, сценарий завершается.

3. **Fallback к медленным фильтрам**
   - Для условий, где `Success = false` и `IsFatal = false`, LLM вызывает MCP `TryPlanSlowFilter`, указывая исходный текст условия и список уже применённых быстрых фильтров.
   - MCP возвращает дескриптор медленного фильтра или явный отказ. Планировщик сохраняет дескриптор в контексте, запускает соответствующий `ExecuteFilter`, обновляет окно билетов и снова проверяет остаток.
   - Если MCP сообщает о невозможности построить фильтр, планировщик немедленно завершает сценарий с ошибкой и возвращает причину.

4. **Выполнение действий**
    - После завершения фильтрации планировщик убеждается, что сформирован единый список действий. Если LLM попытался сопоставить разные действия разным условиям, планировщик возвращает ошибку и просит пользователя уточнить запрос.
    - Быстрые действия исполняются локально поверх списка билетов. Медленные действия используют существующий механизм вызова LLM, но теперь получают контекст и дескриптор из плана.
    - MCP получает `contextId` и `actionDescriptor`, извлекает набор билетов и выполняет требуемые операции.

5. **Отчётность**
   - На каждом шаге контекст хранит статистику: сколько билетов осталось, какие фильтры сработали, какие нет.
   - При ошибках (невозможно построить фильтр, проблемы с MCP) контекст сохраняет статус и причину.

## План внедрения
1. **Расширить функцию построения предикатов**
   - Добавить структуру результата (`Success`, `Predicate`, `FailureReason`).
   - Обновить все вызовы, чтобы обрабатывали статус и не падали при неудаче.

2. **Ввести сущность `FilterContext`**
   - Поля: `ContextId`, список билетов, список фильтров (с типом, статусом, статистикой), флаги завершения.
   - Сервис управления контекстом (создание, обновление, очистка).

3. **Определить интерфейсы фильтров**
    - `IFastFilterBuilder` (Text→Predicate→Result).
    - `ISlowFilterPlanner` (формирование запроса к MCP и обработка ответа).
    - Структура фильтра: `FilterDescriptor { Priority, Type, Source, Status }`.
    - Добавить интерфейсы действий: `IFastActionBuilder` (синтез локальной мини-программы) и `ISlowActionPlanner` (формирование текстового запроса к существующему LLM-коду).

4. **Реализовать планировщик**
    - Метод `PlanFilters(UserRequest request)` делегирует разбор текста сервису планирования условий, который управляет промптом LLM и последовательностью MCP-команд.
    - Для каждого условия сервис сначала вызывает `TryBuildFastPredicate`; при `Success = false, IsFatal = false` инициирует `TryPlanSlowFilter`.
    - При `IsFatal = true` немедленно завершает планирование и возвращает ошибку.
    - После обработки условий сервис переходит к действиям: строит быстрый вариант и только затем использует медленный, если быстрый недоступен.
    - Сохраняет шаги в `FilterContext` и возвращает план (список фильтров + единый список действий).

5. **Интеграция с MCP**
   - Определить RPC/endpoint для `TryBuildFastPredicate`, `TryPlanSlowFilter`, `ExecuteFilter`, `ExecuteActionForContext` (названия команд должны совпадать с теми, что перечисляются в промпте LLM).
   - Обеспечить передачу `contextId` и списка активных фильтров.

6. **Механизм выполнения**
    - Сервис исполнения проходит по плану: быстрые фильтры локально, медленные через MCP, затем быстрые и медленные действия в общей последовательности.
    - При любой фатальной ошибке очищает `contextId` и возвращает причину пользователю.
    - После фильтрации вызывает действие с `contextId`; если действие можно выполнить быстро, оно запускается локально, иначе исполнение делегируется MCP.

7. **Логирование и телеметрия**
   - Логировать успех/провал каждого фильтра, время выполнения, количество оставшихся билетов.
   - Отдельно фиксировать фатальные ошибки планирования (несуществующие поля, неподдерживаемые операции) с точным текстом условия.
   - Эти данные использовать для отладки и улучшения LLM-промптов.

8. **Промптинг LLM**
    - Подготовить шаблон промпта для планировщика: описание ролей, перечисление быстрых и медленных фильтров и действий, формат ответа.
    - Добавить инструкции о том, что быстрые фильтры и действия всегда пробуются первыми, а также что поддерживается только единый набор действий на все условия.

9. **Тестирование**
   - Набор сценариев: только быстрые фильтры, смесь быстрых/медленных, невозможность построить фильтр, пустой результат.
   - Отдельные кейсы fail-fast (несуществующее поле, противоречивые условия), где планировщик должен вернуть ошибку до запуска MCP.
   - Проверить, что действия запускаются только после успешной фильтрации и что контекст очищается.

## Открытые вопросы
- Формат передачи списка билетов между быстрым и медленным этапами (идентификаторы, snapshot, cursor?).
- Требования к идемпотентности действий при повторном запуске.
- Размер и время жизни контекста: хранение в памяти или в отдельном хранилище.
- Как организовать отмену/rollback при ошибке действия.

