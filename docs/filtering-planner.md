# Планировщик фильтров и действий

## Цели и контекст
- Объединить текущие концепции фильтров и действий вокруг единого планировщика.
- Планировщик должен уметь собирать цепочку фильтров, отдающих предикаты для MCP-сервера, и после успешной фильтрации запускать действия над всем отфильтрованным множеством билетов.
- Фильтры делятся на быстрые (конвертация текстового условия в локальный предикат) и медленные (делегирование фильтрации к MCP-серверу/LLM).
- Все операции выполняются внутри контекста сессии пользователя, чтобы фильтры и действия ссылались на один и тот же набор билетов.

## Основные сущности
1. **Контекст планирования**
   - Уникальный идентификатор сессии.
   - Исходный список билетов и текущее «окно» отфильтрованных билетов.
   - Список применённых фильтров с метаданными (тип, источник, эффект).
   - Счётчики промежуточных результатов (оставшиеся билеты, количество отсечённых элементов и т.д.).

2. **Быстрый фильтр**
   - Формируется локально функцией «Text → Predicate».
   - Функция возвращает структуру `PredicateBuildResult { bool Success; Predicate? Value; string? FailureReason; bool IsFatal; }`.
   - `IsFatal = true` означает, что условие невозможно интерпретировать (несуществующее поле, неподдерживаемая операция) и планирование нужно завершить с ошибкой, не переходя к медленному сценарию.
   - При `Success = true` предикат добавляется в контекст и применяется к текущему набору билетов.
   - При `Success = false` и `IsFatal = false` планировщик переходит к медленному сценарию для данного условия.

3. **Медленный фильтр**
   - Структура запроса к MCP-серверу (LLM) с описанием условия и доступных инструментов.
   - Перед формированием запроса планировщик повторно валидирует условие (например, проверяет наличие ссылок на известные поля) и может сразу вернуть ошибку.
   - В результате сервер возвращает дескриптор фильтра (например, SQL-like условие, список идентификаторов или указание на внешнее вычисление).
   - После получения дескриптора планировщик прикрепляет его к контексту и запускает выполнение через MCP.
   - Если медленный фильтр тоже сообщает, что условие невыполнимо, планировщик завершает с ошибкой и очищает контекст.

4. **Действие**
   - Функция MCP «ExecuteActionForFilteredTickets(contextId, actionDescriptor)».
   - Получает ссылку на контекст с накопленными фильтрами и выполняет действие над итоговым набором билетов.

## Пошаговый сценарий работы
1. **Инициализация**
   - Создать контекст планирования для пользовательского запроса (например, «исправить орфографические ошибки для всех билетов с >5 фото и с ошибками»).
   - Запрос формируется в промпт для LLM: "Ты планировщик..." с перечислением доступных быстрых/медленных фильтров и действий.

2. **Прохождение по условиям фильтрации**
   - Для каждого условия ("больше пяти картинок", "есть орфографические ошибки") планировщик пытается построить быстрый фильтр.
   - Запуск функции Text→Predicate.
   - Если `Success = true`, предикат применяется локально, результат фиксируется в контексте.
   - Если `IsFatal = true`, планировщик немедленно возвращает ошибку (например, "поле вес отсутствует") и сообщает пользователю, что запрос невыполним.
   - Если после применения всех быстрых фильтров билетов не осталось, сценарий завершается.

3. **Fallback к медленным фильтрам**
   - Для условий, где `Success = false` и `IsFatal = false`, LLM формирует запрос к MCP с описанием оставшегося условия.
   - MCP возвращает медленный фильтр. Планировщик выполняет его, обновляет контекст и снова проверяет остаток билетов.
   - Если MCP сообщает о невозможности построить фильтр, планировщик немедленно завершает сценарий с ошибкой и возвращает причину.

4. **Выполнение действий**
   - После завершения фильтрации планировщик формирует команду "выполнить действие".
   - MCP получает `contextId` и `actionDescriptor`, извлекает набор билетов и выполняет требуемые операции.

5. **Отчётность**
   - На каждом шаге контекст хранит статистику: сколько билетов осталось, какие фильтры сработали, какие нет.
   - При ошибках (невозможно построить фильтр, проблемы с MCP) контекст сохраняет статус и причину.

## План внедрения
1. **Расширить функцию построения предикатов**
   - Добавить структуру результата (`Success`, `Predicate`, `FailureReason`).
   - Обновить все вызовы, чтобы обрабатывали статус и не падали при неудаче.

2. **Ввести сущность `FilterContext`**
   - Поля: `ContextId`, список билетов, список фильтров (с типом, статусом, статистикой), флаги завершения.
   - Сервис управления контекстом (создание, обновление, очистка).

3. **Определить интерфейсы фильтров**
   - `IFastFilterBuilder` (Text→Predicate→Result).
   - `ISlowFilterPlanner` (формирование запроса к MCP и обработка ответа).
   - Структура фильтра: `FilterDescriptor { Priority, Type, Source, Status }`.

4. **Реализовать планировщик**
   - Метод `PlanFilters(UserRequest request)` разбирает текст, генерирует список условий.
   - Для каждого условия последовательно пробует быстрый фильтр, при отказе — медленный.
   - При `IsFatal = true` немедленно завершает планирование и возвращает ошибку.
   - Сохраняет шаги в `FilterContext` и возвращает план (список фильтров + действие).

5. **Интеграция с MCP**
   - Определить RPC/endpoint для `TryBuildPredicate`, `PlanSlowFilter`, `ExecuteFilter`, `ExecuteActionForContext`.
   - Обеспечить передачу `contextId` и списка активных фильтров.

6. **Механизм выполнения**
   - Сервис исполнения проходит по плану: быстрые фильтры локально, медленные через MCP.
   - При любой фатальной ошибке очищает `contextId` и возвращает причину пользователю.
   - После фильтрации вызывает действие с `contextId`.

7. **Логирование и телеметрия**
   - Логировать успех/провал каждого фильтра, время выполнения, количество оставшихся билетов.
   - Отдельно фиксировать фатальные ошибки планирования (несуществующие поля, неподдерживаемые операции) с точным текстом условия.
   - Эти данные использовать для отладки и улучшения LLM-промптов.

8. **Промптинг LLM**
   - Подготовить шаблон промпта для планировщика: описание ролей, перечисление быстрых и медленных фильтров, формат ответа.
   - Добавить инструкции о том, что быстрые фильтры всегда пробуются первыми, действия — в конце.

9. **Тестирование**
   - Набор сценариев: только быстрые фильтры, смесь быстрых/медленных, невозможность построить фильтр, пустой результат.
   - Отдельные кейсы fail-fast (несуществующее поле, противоречивые условия), где планировщик должен вернуть ошибку до запуска MCP.
   - Проверить, что действия запускаются только после успешной фильтрации и что контекст очищается.

## Открытые вопросы
- Формат передачи списка билетов между быстрым и медленным этапами (идентификаторы, snapshot, cursor?).
- Требования к идемпотентности действий при повторном запуске.
- Размер и время жизни контекста: хранение в памяти или в отдельном хранилище.
- Как организовать отмену/rollback при ошибке действия.

