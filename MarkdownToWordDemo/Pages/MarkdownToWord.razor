@page "/markdown-to-word"
@using Demo.Abstractions
@using Demo.Demos.MarkdownToWord
@using Markdig
@using System.Text

@inject IPageTitleService? TitleService
@inject IJSRuntime JSRuntime
<link rel="stylesheet" href="css/demos.css" />
<style>
@((MarkupString)CharacterVisualizer.GenerateVisualizationCSS())

.invisible-char-controls {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 15px;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 12px;
}

.control-group {
    display: flex;
    align-items: center;
    gap: 8px;
}

.control-group select {
    flex: 1;
}

.btn-clean {
    white-space: normal;
    line-height: 1.2;
}

.view-mode-toggle {
    background: #ffffff;
    border: 2px solid #e0e6ed;
    border-radius: 12px;
    padding: 4px;
    display: inline-flex;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.view-mode-toggle .btn {
    border: none;
    border-radius: 8px;
    padding: 8px 16px;
    transition: all 0.2s ease;
    font-weight: 500;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}

.view-mode-toggle .btn-check:checked + .btn {
    background: linear-gradient(135deg, #007bff, #0056b3);
    color: white;
    box-shadow: 0 2px 8px rgba(0,123,255,0.3);
}

.categories-compact .form-check {
    margin-bottom: 0.25rem;
}

.categories-compact .form-check-label {
    font-size: 0.9rem;
    line-height: 1.3;
}

.categories-compact .card-body {
    padding: 0.75rem;
}

#preview ul,
#preview ol {
    white-space: normal;
    margin-top: 0;
    margin-bottom: 0.5rem;
    padding-left: 1.5rem;
}

#preview li {
    margin-bottom: 0.25rem;
    line-height: 1.25;
}

#preview li:last-child {
    margin-bottom: 0;
}

#preview h2 {
    margin-top: 0;
    margin-bottom: 0.5rem;
    font-size: 1.4rem;
}

#preview p {
    margin-top: 0;
    margin-bottom: 0.5rem;
}

#preview p:last-child {
    margin-bottom: 0;
}
</style>

<PageTitle>Markdown to Word</PageTitle>
<div class="page-container">
    <!-- View Mode Selection -->
    <div class="invisible-char-controls">
        <div class="row mb-3">
            <div class="col-md-6">
                <div class="d-flex align-items-center gap-3">
                    <span class="fw-semibold text-secondary">View Mode:</span>
                    <div class="view-mode-toggle">
                        <input type="radio"
                               class="btn-check"
                               name="viewMode"
                               id="preview"
                               checked="@(CurrentViewMode == ViewMode.Preview)"
                               @onchange="@(() => SetViewMode(ViewMode.Preview))" />
                        <label class="btn" for="preview">
                            <i class="bi bi-eye me-1"></i>Preview
                        </label>

                        <input type="radio"
                               class="btn-check"
                               name="viewMode"
                               id="invisibleChars"
                               checked="@(CurrentViewMode == ViewMode.InvisibleCharacters)"
                               @onchange="@(() => SetViewMode(ViewMode.InvisibleCharacters))" />
                        <label class="btn" for="invisibleChars">
                            <i class="bi bi-search me-1"></i>Invisible Chars
                        </label>
                    </div>
                </div>
            </div>
        </div>

        @if (CurrentViewMode == ViewMode.InvisibleCharacters)
        {
            <div class="row mb-3">
                <div class="col-md-6">
                    <div class="control-group w-100">
                        <label class="form-label mb-0" for="presetSelect">Cleaning preset</label>
                        <select id="presetSelect" class="form-select" @bind="selectedDropdownValue" @bind:after="OnDropdownChange">
                            <option value="">-- Select Action --</option>
                            <option value="SelectAll">✓ Select All</option>
                            <option value="UnselectAll">✗ Unselect All</option>
                            <option value="@CleaningPreset.Safe">Safe</option>
                            <option value="@CleaningPreset.Aggressive">Aggressive</option>
                            <option value="@CleaningPreset.ASCIIStrict">ASCII-Strict</option>
                            <option value="@CleaningPreset.TypographySoft">Typography-Soft</option>
                            <option value="@CleaningPreset.RTLSafe">RTL-Safe</option>
                            <option value="@CleaningPreset.SEOPlain">SEO/Plain</option>
                        </select>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="d-flex align-items-end gap-2">
                        <button class="btn btn-warning btn-clean" @onclick="DeleteInvisibleCharacters" disabled="@(!HasCharactersToClean)">
                            <i class="bi bi-trash me-1"></i>Clean Selected (@CharactersToCleanCount)
                        </button>
                    </div>
                </div>
            </div>

            <div class="row mb-3">
                <div class="col-12">
                    <div class="card categories-compact">
                        <div class="card-header py-2">
                            <h6 class="mb-0 fs-6">Invisible Character Categories</h6>
                        </div>
                        <div class="card-body">
                            <div class="row g-2">
                                @foreach (var category in Enum.GetValues<InvisibleCharacterCategory>())
                                {
                                    <div class="col-md-3 col-sm-4 col-6">
                                        <div class="form-check">
                                            <input class="form-check-input" 
                                                   type="checkbox" 
                                                   id="cat-@category" 
                                                   checked="@EnabledCategories.Contains(category)"
                                                   @onchange="@(e => ToggleCategory(category, (bool)e.Value!))" />
                                            <label class="form-check-label" for="cat-@category">
                                                @GetCategoryDisplayName(category)
                                            </label>
                                        </div>
                                    </div>
                                }
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        }
    </div>

    <!-- Existing Controls -->
    <div>
        <div class="mb-2">
            <button class="btn btn-secondary" @onclick='() => ToggleMarkdownAction("**")' style="font-weight: bold;">B</button>
            <button class="btn btn-secondary" @onclick='() => ToggleMarkdownAction("_")' style="font-style: italic;">I</button>
            <button class="btn btn-secondary" @onclick='() => ToggleMarkdownAction("~~")' style="text-decoration: line-through;">S</button>
            <button class="btn btn-secondary" @onclick="ApplyDiacriticStrikeAction" title="Layer combining marks for an intense strikeout">M̴a̷n̶g̵l̷e̴</button>
            <button class="btn btn-secondary" @onclick='() => ToggleMarkdownAction("`")' style="font-family: monospace;">`code`</button>
            <button class="btn btn-info ms-3" @onclick="LoadExample" title="Load compact text with invisible characters for testing">Show Example</button>
        </div>
    </div>

    <div class="d-flex" style="height: calc(100vh - 200px);">
        <div class="form-group" style="width: 50%; margin-right: 1rem; display: flex; flex-direction: column;">
            <label for="markdownInput" class="form-label">Markdown Content</label>
            <textarea id="markdownInput" class="form-control" style="flex-grow: 1; resize: none;" @ref="MarkdownTextArea" @oninput="OnInput">@MarkdownContent</textarea>
        </div>

        <div class="form-group" style="width: 50%; display: flex; flex-direction: column;">
            <label class="form-label">@(CurrentViewMode == ViewMode.Preview ? "Preview" : "Text with Invisible Characters")</label>
            <div id="preview" class="form-control" style="flex-grow: 1; overflow-y: auto; white-space: pre-wrap;">
                @if (CurrentViewMode == ViewMode.InvisibleCharacters)
                {
                    @((MarkupString)VisualizedPreview)
                }
                else
                {
                    @((MarkupString)MarkdownPreview)
                }
            </div>
        </div>
    </div>

    <div class="d-flex align-items-center mt-2">
        <a class="btn btn-primary" href="@DownloadUrl" download="ExportedDocument.doc">Download as Word</a>
        <p class="text-primary ms-3" style="font-style: italic;">All processing is done entirely in your browser, and no data is transmitted to any server.</p>
    </div>
</div>

@code {
    private enum ViewMode
    {
        Preview,
        InvisibleCharacters
    }

    private ElementReference MarkdownTextArea;
    private string MarkdownContent { get; set; } = string.Empty;
    private string MarkdownPreview { get; set; } = string.Empty;
    private string VisualizedPreview { get; set; } = string.Empty;
    private string DownloadUrl { get; set; } = string.Empty;
    private DetectionResult LatestDetectionResult { get; set; } = new();
    private InvisibleCharacterDetectorService CharacterDetector { get; } = new();
    private InvisibleCharacterVisualizationService CharacterVisualizer { get; } = new();
    private InvisibleCharacterCleanerService CharacterCleaner { get; } = new();
    private Markdig.MarkdownPipeline MarkdownPipeline =
        new Markdig.MarkdownPipelineBuilder()
        .UseEmphasisExtras()
        .Build();

    private ViewMode CurrentViewMode { get; set; } = ViewMode.Preview;
    private bool ShowInvisibleCharacters => CurrentViewMode == ViewMode.InvisibleCharacters;
    private HashSet<InvisibleCharacterCategory> EnabledCategories { get; set; } = new();

    private static readonly IReadOnlyDictionary<CleaningPreset, InvisibleCharacterCategory[]> PresetCategoryMap =
        new Dictionary<CleaningPreset, InvisibleCharacterCategory[]>
        {
            [CleaningPreset.Safe] = new[]
            {
                InvisibleCharacterCategory.C0C1Controls,
                InvisibleCharacterCategory.LineBreaks,
                InvisibleCharacterCategory.Tab,
                InvisibleCharacterCategory.WideSpaces,
                InvisibleCharacterCategory.ZeroWidthFormat,
                InvisibleCharacterCategory.BiDiControls,
                InvisibleCharacterCategory.SoftHyphen,
                InvisibleCharacterCategory.InvisibleMath
            },
            [CleaningPreset.Aggressive] = new[]
            {
                InvisibleCharacterCategory.C0C1Controls,
                InvisibleCharacterCategory.LineBreaks,
                InvisibleCharacterCategory.Tab,
                InvisibleCharacterCategory.WideSpaces,
                InvisibleCharacterCategory.NoBreakSpaces,
                InvisibleCharacterCategory.ZeroWidthFormat,
                InvisibleCharacterCategory.BiDiControls,
                InvisibleCharacterCategory.SoftHyphen,
                InvisibleCharacterCategory.InvisibleMath,
                InvisibleCharacterCategory.VariationSelectors,
                InvisibleCharacterCategory.EmojiTags,
                InvisibleCharacterCategory.CombiningMarks,
                InvisibleCharacterCategory.Confusables
            },
            [CleaningPreset.ASCIIStrict] = new[]
            {
                InvisibleCharacterCategory.C0C1Controls,
                InvisibleCharacterCategory.LineBreaks,
                InvisibleCharacterCategory.Tab,
                InvisibleCharacterCategory.WideSpaces,
                InvisibleCharacterCategory.NoBreakSpaces,
                InvisibleCharacterCategory.ZeroWidthFormat,
                InvisibleCharacterCategory.BiDiControls,
                InvisibleCharacterCategory.SoftHyphen,
                InvisibleCharacterCategory.InvisibleMath,
                InvisibleCharacterCategory.VariationSelectors,
                InvisibleCharacterCategory.EmojiTags,
                InvisibleCharacterCategory.Confusables
            },
            [CleaningPreset.TypographySoft] = new[]
            {
                InvisibleCharacterCategory.C0C1Controls,
                InvisibleCharacterCategory.LineBreaks,
                InvisibleCharacterCategory.Tab,
                InvisibleCharacterCategory.WideSpaces,
                InvisibleCharacterCategory.ZeroWidthFormat,
                InvisibleCharacterCategory.BiDiControls,
                InvisibleCharacterCategory.SoftHyphen,
                InvisibleCharacterCategory.InvisibleMath
            },
            [CleaningPreset.RTLSafe] = new[]
            {
                InvisibleCharacterCategory.C0C1Controls,
                InvisibleCharacterCategory.LineBreaks,
                InvisibleCharacterCategory.Tab,
                InvisibleCharacterCategory.WideSpaces,
                InvisibleCharacterCategory.ZeroWidthFormat,
                InvisibleCharacterCategory.SoftHyphen,
                InvisibleCharacterCategory.InvisibleMath
            },
            [CleaningPreset.SEOPlain] = new[]
            {
                InvisibleCharacterCategory.C0C1Controls,
                InvisibleCharacterCategory.LineBreaks,
                InvisibleCharacterCategory.Tab,
                InvisibleCharacterCategory.WideSpaces,
                InvisibleCharacterCategory.NoBreakSpaces,
                InvisibleCharacterCategory.ZeroWidthFormat,
                InvisibleCharacterCategory.BiDiControls,
                InvisibleCharacterCategory.SoftHyphen,
                InvisibleCharacterCategory.InvisibleMath,
                InvisibleCharacterCategory.VariationSelectors,
                InvisibleCharacterCategory.EmojiTags,
                InvisibleCharacterCategory.Confusables
            }
        };

    private string selectedDropdownValue = "";

    private async Task OnDropdownChange()
    {
        var value = selectedDropdownValue;
        
        if (value == "SelectAll")
        {
            await SelectAllCategories();
        }
        else if (value == "UnselectAll")
        {
            await UnselectAllCategories();
        }
        else if (Enum.TryParse<CleaningPreset>(value, out var preset))
        {
            ApplyPresetCategories(preset);
            await UpdatePreview();
        }
        
        StateHasChanged();
    }
    
    private async Task SelectAllCategories()
    {
        EnabledCategories = new HashSet<InvisibleCharacterCategory>(Enum.GetValues<InvisibleCharacterCategory>());
        await UpdatePreview();
        StateHasChanged();
    }
    
    private async Task UnselectAllCategories()
    {
        EnabledCategories.Clear();
        await UpdatePreview();
        StateHasChanged();
    }

    private bool HasCharactersToClean => EnabledCategories.Count > 0 &&
        LatestDetectionResult.DetectedCharacters.Any(dc => EnabledCategories.Contains(dc.Category));

    private int CharactersToCleanCount => EnabledCategories.Count == 0
        ? 0
        : LatestDetectionResult.DetectedCharacters.Count(dc => EnabledCategories.Contains(dc.Category));
    
    // Visualization options
    private VisualizationOptions VisualizationOptions => new()
    {
        ShowInvisibleCharacters = ShowInvisibleCharacters,
        SkipCodeBlocks = true,
        ShowLineBreaks = true,
        EnabledCategories = EnabledCategories
    };

    protected override async Task OnInitializedAsync()
    {
        base.OnInitialized();
        TitleService?.SetTitle("Markdown to Word");

        // Initialize with Safe preset by default
        ApplyPresetCategories(CleaningPreset.Safe);
        selectedDropdownValue = CleaningPreset.Safe.ToString();

        await UpdatePreview();
    }

    private void ApplyPresetCategories(CleaningPreset preset)
    {
        if (PresetCategoryMap.TryGetValue(preset, out var categories))
        {
            EnabledCategories = new HashSet<InvisibleCharacterCategory>(categories);
        }
        else
        {
            EnabledCategories = new HashSet<InvisibleCharacterCategory>(Enum.GetValues<InvisibleCharacterCategory>());
        }
    }

    private async Task ToggleMarkdownAction(string markdownSymbol)
    {
        var selectionStart = await JSRuntime.InvokeAsync<int>("getSelectionStart", MarkdownTextArea);
        var selectionEnd = await JSRuntime.InvokeAsync<int>("getSelectionEnd", MarkdownTextArea);

        if (selectionStart >= 0 && selectionEnd > selectionStart)
        {
            MarkdownContent = MarkdownProcessor.ToggleMarkdown(MarkdownContent, selectionStart, selectionEnd, markdownSymbol);

            // Update the textarea content explicitly
            await JSRuntime.InvokeVoidAsync("updateTextAreaContent", MarkdownTextArea, MarkdownContent);

            // Update preview
            await UpdatePreview();
        }
    }

    private async Task ApplyDiacriticStrikeAction()
    {
        var selectionStart = await JSRuntime.InvokeAsync<int>("getSelectionStart", MarkdownTextArea);
        var selectionEnd = await JSRuntime.InvokeAsync<int>("getSelectionEnd", MarkdownTextArea);

        if (selectionStart >= 0 && selectionEnd > selectionStart)
        {
            MarkdownContent = MarkdownProcessor.ApplyDiacriticStrike(MarkdownContent, selectionStart, selectionEnd);

            await JSRuntime.InvokeVoidAsync("updateTextAreaContent", MarkdownTextArea, MarkdownContent);

            await UpdatePreview();
        }
    }

    private async Task OnInput(ChangeEventArgs e)
    {
        MarkdownContent = e.Value?.ToString() ?? string.Empty;
        await UpdatePreview();
    }

    private Task UpdatePreview()
    {
        var content = MarkdownContent ?? string.Empty;
        LatestDetectionResult = CharacterDetector.DetectInvisibleCharacters(content);
        MarkdownPreview = Markdig.Markdown.ToHtml(content, MarkdownPipeline);

        if (CurrentViewMode == ViewMode.InvisibleCharacters)
        {
            // Generate visualized preview with only enabled categories
            var visualizedMarkdown = CharacterVisualizer.VisualizeInvisibleCharacters(content, VisualizationOptions);
            VisualizedPreview = Markdig.Markdown.ToHtml(visualizedMarkdown, MarkdownPipeline);
        }
        else
        {
            VisualizedPreview = MarkdownPreview;
        }

        GenerateDownloadUrl();
        return Task.CompletedTask;
    }

    private void GenerateDownloadUrl()
    {
        string htmlContent = Markdig.Markdown.ToHtml(MarkdownContent, MarkdownPipeline); // Convert Markdown to HTML

        // Wrap HTML content into a basic Word file structure
        string wordContent = $@"<html xmlns:o='urn:schemas-microsoft-com:office:office'
                            xmlns:w='urn:schemas-microsoft-com:office:word'
                            xmlns='http://www.w3.org/TR/REC-html40'>
<head><meta charset='utf-8'></head>
<body>{htmlContent}</body>
</html>";

        // Convert the content to base64 string
        var byteArray = Encoding.UTF8.GetBytes(wordContent);
        DownloadUrl = "data:application/msword;base64," + Convert.ToBase64String(byteArray);
    }

    private async Task SetViewMode(ViewMode mode)
    {
        CurrentViewMode = mode;
        await UpdatePreview();
        StateHasChanged();
    }

    private async Task ToggleCategory(InvisibleCharacterCategory category, bool enabled)
    {
        if (enabled)
        {
            EnabledCategories.Add(category);
        }
        else
        {
            EnabledCategories.Remove(category);
        }
        
        await UpdatePreview();
        StateHasChanged();
    }

    private async Task DeleteInvisibleCharacters()
    {
        if (!HasCharactersToClean)
            return;

        // Remove only the categories selected by the user
        var cleaningOptions = new CleaningOptions
        {
            SkipCodeBlocks = true,
            TabSize = 4,
            InvisibleMathToSpace = true
        };

        var result = CharacterCleaner.CleanSelectedCategories(MarkdownContent, EnabledCategories, cleaningOptions);

        if (!result.HasChanges)
            return;

        MarkdownContent = result.CleanedText;

        await JSRuntime.InvokeVoidAsync("updateTextAreaContent", MarkdownTextArea, MarkdownContent);
        await UpdatePreview();

        StateHasChanged();
    }



    private string GetCategoryDisplayName(InvisibleCharacterCategory category)
    {
        return category switch
        {
            InvisibleCharacterCategory.C0C1Controls => "C0/C1 Controls",
            InvisibleCharacterCategory.LineBreaks => "Line Breaks",
            InvisibleCharacterCategory.Tab => "Tab",
            InvisibleCharacterCategory.WideSpaces => "Wide Spaces",
            InvisibleCharacterCategory.NoBreakSpaces => "No-Break Spaces",
            InvisibleCharacterCategory.ZeroWidthFormat => "Zero Width Format",
            InvisibleCharacterCategory.BiDiControls => "BiDi Controls",
            InvisibleCharacterCategory.SoftHyphen => "Soft Hyphen",
            InvisibleCharacterCategory.InvisibleMath => "Invisible Math",
            InvisibleCharacterCategory.VariationSelectors => "Variation Selectors",
            InvisibleCharacterCategory.EmojiTags => "Emoji Tags",
            InvisibleCharacterCategory.CombiningMarks => "Combining Marks",
            InvisibleCharacterCategory.Confusables => "Confusables",
            _ => category.ToString()
        };
    }

    private async Task LoadExample()
    {
        var demoContent = InvisibleUnicodeDemoGenerator.BuildMarkdown();
        MarkdownContent = demoContent;

        await JSRuntime.InvokeVoidAsync("updateTextAreaContent", MarkdownTextArea, MarkdownContent);
        await UpdatePreview();

        StateHasChanged();
    }
}
